<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on echo :)</title>
    <link>https://h45h.fun/posts/</link>
    <description>Recent content in Posts on echo :)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Nov 2024 18:09:10 +0800</lastBuildDate><atom:link href="https://h45h.fun/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intro 2 Isogeny</title>
      <link>https://h45h.fun/posts/intro-2-isogeny/</link>
      <pubDate>Fri, 01 Nov 2024 18:09:10 +0800</pubDate>
      
      <guid>https://h45h.fun/posts/intro-2-isogeny/</guid>
      <description>TL:DR ä¸€äº›å…³äº SIDHã€CSIDH çš„ç›´è§‚ç†è§£ï¼Œä»¥åŠæ­¤å‰å‡ºè¿‡æˆ–é‡è§çš„åç®€å•é€‚åˆå…¥æ‰‹çš„åŒæºé¢˜ç›®ã€‚
ä»Šå¹´æš‘å‡ Crypto Hack æ›´æ–°äº†ä¸€äº›ä¸ Isogeny ç›¸å…³çš„ä¸œè¥¿ï¼Œæ¯”è¾ƒæ¨èä¸Šæ‰‹åšä¸€åšï¼Œé€‚åˆå…¥é—¨ã€‚
Isogeny Background æ›²çº¿åŒæºä¸åŒäºä¼ ç»Ÿå¯†ç å­¦ä¸­æ›²çº¿ç¦»æ•£å¯¹æ•°(ECDLP)çš„å†…å®¹ï¼Œåœ¨æ­¤å‰æˆ‘ä»¬æ›´å¤šåœ°ç ”ç©¶å·²çŸ¥ç­‰å¼ $[a]P=Q$ ä¸­çš„ $P,Q$ è¦æ±‚æ‰¾åˆ° $[a]$ã€‚è¿™ç›¸å½“äºæ˜¯è€ƒè™‘ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œä½†åœ¨æ›²çº¿åŒæºä¸­ç ”ç©¶çš„æ˜¯æ›²çº¿ä¹‹é—´çš„å…³ç³»ã€‚ç”±äºé‡å­è®¡ç®—æœºä»¥åŠ Shor ç®—æ³•çš„äº§ç”Ÿï¼Œåé‡å­å¯†ç å­¦å¾—åˆ°äº†å¾ˆå¤šçš„å…³æ³¨ï¼ŒåŸºäºæ›²çº¿åŒæºçš„å¯†ç å­¦å°±æ˜¯å…¶ä¸­ä¸€ç§ï¼Œåœ¨æ­¤å‰Niståé‡å­çš„å€™é€‰ä¸­è¿˜æœ‰ä¸€äº›å…¶ä»–çš„è¯¸å¦‚åŸºäºæ ¼ï¼ŒåŸºäºç¼–ç ï¼ŒåŸºäºå¤šå˜é‡ï¼ŒåŸºäºå“ˆå¸Œå‡½æ•°ï¼ŒåŸºäºMPCçš„å¯†ç ä½“ç³»ç­‰ç­‰ã€‚ç›¸æ¯”å…¶ä»–ä½“ç³»åŸºäºæ›²çº¿åŒæºçš„å¯†ç å­¦ä¼˜åŠ¿åœ¨äºå…¶å¯†é’¥çŸ­ï¼Œä½†ç¼ºç‚¹æ˜¯è®¡ç®—é€Ÿåº¦è¾ƒæ…¢ã€‚
Curve Isogenyï¼ˆæ›²çº¿åŒæºï¼Œä¸‹ç®€è®°ä¸ºåŒæºï¼‰æ˜¯ä»€ä¹ˆï¼ŸğŸ¤”
åŒæºå…¶å®å°±æ˜¯ä¸€ç§æ€å°„ï¼Œæˆ–è€…è¯´æ˜¯ä¸€ä¸ªæœ‰ç†å‡½æ•°ã€‚å¯¹äºæ›²çº¿ $E_1,E_2$ ï¼Œæ˜ å°„ $\phi:E_1\rightarrow E_2$ æ»¡è¶³å¯¹äºä»»æ„ä¸¤ç‚¹ $P,Q\in E_1$ æœ‰ $\phi(P&#43;Q)=\phi(P)&#43;\phi(Q)$ ï¼Œå¹¶ä¸” $\phi(O_{E_1})=O_{E_2}$ ï¼Œæˆ‘ä»¬ç§°è¿™æ ·çš„å‡½æ•° $\phi$ ä¸ºæ›²çº¿ $E_1$ åˆ° $E_2$ çš„åŒæºã€‚
å¯¹äºä¸€ä¸ªæ€å°„æˆ‘ä»¬ç»å¸¸ä¼šè€ƒè™‘å®ƒçš„åŸåƒã€åƒä»¥åŠæ ¸($Ker(\phi)=\set{X|\phi(X)=O}$)ã€‚åœ¨ä¸åŒæºç›¸å…³çš„å¯†ç ç³»ç»Ÿä¸­é€šå¸¸åšçš„æœ€å¤šçš„æœ‰ä¸¤ç§æ“ä½œï¼Œåœ¨ç»™å‡ºæ›²çº¿å’Œæ ¸çš„æƒ…å†µä¸‹è®¡ç®—åŒæºï¼Œåœ¨å·²çŸ¥åŒæºçš„æƒ…å†µä¸‹è¯„ä¼°åŸåƒä¸Šç‚¹åœ¨åƒä¸Šå¯¹åº”çš„ç‚¹ã€‚
å®é™…ä¸Šé™¤äº†æœ‰å…³æ›²çº¿çš„åŒæºè¿˜æœ‰å„ç§å¥‡æ€ªæ•°å­¦ç»“æ„çš„åŒæºé—®é¢˜ï¼Œåƒç¼–ç åŒæºæˆ–è€…å¤šå˜é‡åŒæºç­‰ï¼Œå°±çœ‹æ€ä¹ˆå®šä¹‰æ˜ å°„äº†ã€‚
åœ¨ SageMath é€šè¿‡åŸåƒåŠå¯¹åº”çš„æ ¸å®šä¹‰åŒæº $\phi$
sage: ells = [*primes(3, 250), 661] sage: p = 4 * prod(ells) - 1 sage: F = GF(p, &amp;#39;i&amp;#39;) sage: A = 0 sage: E = EllipticCurve(F, [0, A, 0, 1, 0]) sage: while not (P := (p &#43; 1) // 3 * E.</description>
      <content:encoded><![CDATA[<h1 id="tldr">TL:DR</h1>
<blockquote>
<p>ä¸€äº›å…³äº SIDHã€CSIDH çš„ç›´è§‚ç†è§£ï¼Œä»¥åŠæ­¤å‰å‡ºè¿‡æˆ–é‡è§çš„åç®€å•é€‚åˆå…¥æ‰‹çš„åŒæºé¢˜ç›®ã€‚</p>
</blockquote>
<p>ä»Šå¹´æš‘å‡ Crypto Hack æ›´æ–°äº†ä¸€äº›ä¸ Isogeny ç›¸å…³çš„ä¸œè¥¿ï¼Œæ¯”è¾ƒæ¨èä¸Šæ‰‹åšä¸€åšï¼Œé€‚åˆå…¥é—¨ã€‚</p>
<h1 id="isogeny">Isogeny</h1>
<h2 id="background">Background</h2>
<p>æ›²çº¿åŒæºä¸åŒäºä¼ ç»Ÿå¯†ç å­¦ä¸­æ›²çº¿ç¦»æ•£å¯¹æ•°(ECDLP)çš„å†…å®¹ï¼Œåœ¨æ­¤å‰æˆ‘ä»¬æ›´å¤šåœ°ç ”ç©¶å·²çŸ¥ç­‰å¼ $[a]P=Q$ ä¸­çš„ $P,Q$ è¦æ±‚æ‰¾åˆ° $[a]$ã€‚è¿™ç›¸å½“äºæ˜¯è€ƒè™‘ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œä½†åœ¨æ›²çº¿åŒæºä¸­ç ”ç©¶çš„æ˜¯æ›²çº¿ä¹‹é—´çš„å…³ç³»ã€‚ç”±äºé‡å­è®¡ç®—æœºä»¥åŠ Shor ç®—æ³•çš„äº§ç”Ÿï¼Œåé‡å­å¯†ç å­¦å¾—åˆ°äº†å¾ˆå¤šçš„å…³æ³¨ï¼ŒåŸºäºæ›²çº¿åŒæºçš„å¯†ç å­¦å°±æ˜¯å…¶ä¸­ä¸€ç§ï¼Œåœ¨æ­¤å‰Niståé‡å­çš„å€™é€‰ä¸­è¿˜æœ‰ä¸€äº›å…¶ä»–çš„è¯¸å¦‚åŸºäºæ ¼ï¼ŒåŸºäºç¼–ç ï¼ŒåŸºäºå¤šå˜é‡ï¼ŒåŸºäºå“ˆå¸Œå‡½æ•°ï¼ŒåŸºäºMPCçš„å¯†ç ä½“ç³»ç­‰ç­‰ã€‚ç›¸æ¯”å…¶ä»–ä½“ç³»åŸºäºæ›²çº¿åŒæºçš„å¯†ç å­¦ä¼˜åŠ¿åœ¨äºå…¶å¯†é’¥çŸ­ï¼Œä½†ç¼ºç‚¹æ˜¯è®¡ç®—é€Ÿåº¦è¾ƒæ…¢ã€‚</p>
<blockquote>
<p>Curve Isogenyï¼ˆæ›²çº¿åŒæºï¼Œä¸‹ç®€è®°ä¸ºåŒæºï¼‰æ˜¯ä»€ä¹ˆï¼ŸğŸ¤”</p>
</blockquote>
<p>åŒæºå…¶å®å°±æ˜¯ä¸€ç§æ€å°„ï¼Œæˆ–è€…è¯´æ˜¯ä¸€ä¸ªæœ‰ç†å‡½æ•°ã€‚å¯¹äºæ›²çº¿ $E_1,E_2$ ï¼Œæ˜ å°„ $\phi:E_1\rightarrow E_2$ æ»¡è¶³å¯¹äºä»»æ„ä¸¤ç‚¹ $P,Q\in E_1$ æœ‰ $\phi(P+Q)=\phi(P)+\phi(Q)$ ï¼Œå¹¶ä¸” $\phi(O_{E_1})=O_{E_2}$ ï¼Œæˆ‘ä»¬ç§°è¿™æ ·çš„å‡½æ•° $\phi$ ä¸ºæ›²çº¿ $E_1$ åˆ° $E_2$ çš„åŒæºã€‚</p>
<p>å¯¹äºä¸€ä¸ªæ€å°„æˆ‘ä»¬ç»å¸¸ä¼šè€ƒè™‘å®ƒçš„åŸåƒã€åƒä»¥åŠæ ¸($Ker(\phi)=\set{X|\phi(X)=O}$)ã€‚åœ¨ä¸åŒæºç›¸å…³çš„å¯†ç ç³»ç»Ÿä¸­é€šå¸¸åšçš„æœ€å¤šçš„æœ‰ä¸¤ç§æ“ä½œï¼Œåœ¨ç»™å‡ºæ›²çº¿å’Œæ ¸çš„æƒ…å†µä¸‹è®¡ç®—åŒæºï¼Œåœ¨å·²çŸ¥åŒæºçš„æƒ…å†µä¸‹è¯„ä¼°åŸåƒä¸Šç‚¹åœ¨åƒä¸Šå¯¹åº”çš„ç‚¹ã€‚</p>
<p>å®é™…ä¸Šé™¤äº†æœ‰å…³æ›²çº¿çš„åŒæºè¿˜æœ‰å„ç§å¥‡æ€ªæ•°å­¦ç»“æ„çš„åŒæºé—®é¢˜ï¼Œåƒç¼–ç åŒæºæˆ–è€…å¤šå˜é‡åŒæºç­‰ï¼Œå°±çœ‹æ€ä¹ˆå®šä¹‰æ˜ å°„äº†ã€‚</p>
<p>åœ¨ SageMath é€šè¿‡åŸåƒåŠå¯¹åº”çš„æ ¸å®šä¹‰åŒæº $\phi$</p>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: F = GF(p, &#39;i&#39;)
sage: A = 0
sage: E = EllipticCurve(F, [0, A, 0, 1, 0])
sage: while not (P := (p + 1) // 3 * E.random_element()): pass
sage: Ï† = E.isogeny(P)
</code></pre><p>æ ¸å’Œæ˜ å°„ä¹‹é—´æ»¡è¶³çš„å…³ç³»</p>
<pre tabindex="0"><code>sage: P.order() == Ï†.degree()
</code></pre><p>å®é™…ä¸Šï¼Œä¹‹å‰çš„è¡¨è¿°å¹¶ä¸ä¸¥è°¨ï¼Œæ ¸å¾ˆæ˜æ˜¾åº”è¯¥ä¸ºä¸€é›†åˆï¼Œä½†è¿™é‡Œåªæ˜¯å°† $P$ ä½œä¸ºäº†å‚æ•°ï¼Œå®é™…ä¸Šè¿™ä»£è¡¨äº†è¿™æ ·ä¸€ä¸ªé›†åˆ $\set{k\cdot P|k\in \mathbb{Z}}$ï¼Œæ›´ç®€æ´çš„å¯ä»¥æŠŠè¿™è®°ä¸º n-torsion (å…¶ä¸­ $n$ ä¸º $P$ çš„é˜¶)ã€‚é€šè¿‡å®éªŒï¼Œå¯ä»¥å‘ç°åŒæºçš„åº¦æ•°å’Œæ ¸çš„åŠ¿ç›¸ç­‰ï¼Œå½“ç„¶åº”è¯¥æœ‰æ›´ä¸¥è°¨çš„è¯´æ³•ï¼Œé™äºæ°´å¹³åªèƒ½é€šè¿‡ç±»ä¼¼å®éªŒçš„æ–¹å¼å»éªŒè¯åŒæºçš„å¤§å¤šæ•°æ€§è´¨äº†ã€‚</p>
<blockquote>
<p>åŸºäºåŒæºçš„å›°éš¾é—®é¢˜æ˜¯ä»€ä¹ˆï¼ŸğŸ˜–</p>
</blockquote>
<p>è¿™å¤§æ¦‚æ˜¯å…¥æ‰‹åŒæºæ—¶æœ€è´¹è§£çš„ä¸€ä¸ªé—®é¢˜äº†ï¼Œä¸åŒäºæ­¤å‰æ¥è§¦è¿‡çš„åŸºäºå¤§æ•´æ•°åˆ†è§£ã€ç¦»æ•£å¯¹æ•°ã€æ ¼ä¸ŠçŸ­å‘é‡é—®é¢˜ï¼ŒåŒæºçš„å›°éš¾æ€§ç†è§£èµ·æ¥æœ‰ç‚¹æŠ½è±¡ã€‚ç®€å•æ¥è®²å°±æ˜¯ç»™å®šåŸåƒ $E$ å’Œåƒ $E&rsquo;$ æ‰¾åˆ°å®ƒä»¬é—´çš„æ˜ å°„ $\phi$ æ˜¯å›°éš¾çš„ï¼Œå½“ç„¶è¿™ä¸ªå›°éš¾ç¨‹åº¦å’Œæˆ‘ä»¬é€‰æ‹©çš„å‚æ•°æœ‰å…³ç³»ï¼Œå¯¹äºå°è§„æ¨¡å‚æ•°ä¸‹çš„é—®é¢˜æˆ‘ä»¬åªéœ€è¦æšä¸¾æ‰€æœ‰å¯èƒ½æƒ…å†µå³å¯æ±‚è§£ã€‚è¿™é‡Œç»™å‡ºä¸€äº›ç›´è§‰ä¸Šçš„ç†è§£ï¼ŒåŒæºç›¸å…³çš„å›°éš¾é—®é¢˜å¾€å¾€å¯ä»¥è§†ä¸ºåœ¨ä¸€ä¸ªèŠ‚ç‚¹æ•°ç‰¹åˆ«å¤šçš„å¤æ‚å›¾ç»“æ„ä¸­æ‰¾åˆ°ä¸¤ç‚¹ä¹‹é—´çš„è·¯å¾„ï¼Œåé¢ä¼šæåˆ°çš„ SIDH å°±æ˜¯ 2-isogeny graph, 3-isogeny graphï¼Œè€Œ CSIDH åˆ™æ˜¯ç›¸å¯¹æ›´å·¥æ•´ä¸€ç‚¹çš„å›¾ã€‚</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241024131955290.png" alt="image-20241024131032466"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241024131032466.png" alt="image-20241024131032466"></p>
<h2 id="basics">Basics</h2>
<blockquote>
<p>å…·ä½“ä»‹ç»åŒæºç›¸å…³çš„å¯†ç å­¦åè®®å‰å…ˆè¡¥å……ä¸€éƒ¨åˆ†å¿…è¦çš„æ›²çº¿ğŸ§€ã€‚</p>
</blockquote>
<p><strong>Supersingular Elliptic Curve</strong></p>
<p>è®° $q=p^k$ï¼Œå½“æ»¡è¶³ $\verb|#|E(F_q)\equiv1(mod\ p)$ æ—¶æˆ‘ä»¬ç§°æ›²çº¿ $E$ ä¸ºè¶…å¥‡å¼‚æ¤­åœ†æ›²çº¿ã€‚</p>
<p>å®é™…ä¸Šå¯¹äºè¶…å¥‡å¼‚æ¤­åœ†æ›²çº¿çš„å®šä¹‰æœ‰éå¸¸å¤šç§ï¼Œæœ‰ä¸€ç§æ¯”è¾ƒæœ‰è¶£çš„ <em>End(E) is an order in a quaternion algebra</em>ï¼Œè¿™ä¸ªå®šä¹‰æ–¹å¼å¯èƒ½å¯¹äºç†è§£åé¢ SIDH æ˜¯æœ‰ç›Šçš„ã€‚</p>
<p>è¶…å¥‡å¼‚æ›²çº¿ä¸Šçš„ ECDLP æ˜¯è„†å¼±çš„ï¼ŒMOV attack å¯ä»¥è®¡ç®—ä½åµŒå…¥åº¦æ›²çº¿ä¸Šçš„ ECDLPã€‚ä½†æ˜¯åœ¨åŒæºä¸­é‡‡ç”¨è¶…å¥‡å¼‚æ›²çº¿åœ¨ä¿è¯å®‰å…¨æ€§çš„åŒæ—¶ä¼šå¸¦æ¥æ›´å¿«çš„è®¡ç®—é€Ÿåº¦ã€‚</p>
<pre tabindex="0"><code>sage: E.is_supersingular()
</code></pre><p><strong>j-invariant</strong></p>
<p>ç”¨æ¥åˆ¤æ–­ä¸¤æ›²çº¿æ˜¯å¦å…·æœ‰åŒæ„å…³ç³»çš„é‡ï¼Œè‹¥ä¸¤æ›²çº¿çš„ j-invariant ç›¸ç­‰åˆ™ä¸¤æ›²çº¿åœ¨å½“å‰åŸŸæˆ–å…¶æ‰©å¼ ä¸Šå­˜åœ¨åŒæ„å…³ç³»ã€‚</p>
<p>æ›²çº¿ $E:\ y=x^3+Ax+B$  çš„ j-invariant å¯è¡¨ç¤ºä¸º $j(E)=j(A,B)=1728\frac{4A^3}{4A^3+27B^2}$</p>
<pre tabindex="0"><code>sage: E.j_invariant()
</code></pre><p><strong>Montgomery model</strong></p>
<p>å½¢å¦‚ $E:\ y^2=x^3+Ax^2+x$ çš„æ›²çº¿ï¼Œè¿™ç§å½¢å¼åœ¨ CSIDH çš„ action group æ„é€ ä¸Šä¼šç”¨åˆ°ã€‚å®é™…ä¸Šè¿™é‡Œçš„ $A$ ä¹Ÿå¯ä»¥è§†ä¸ºä¸€ç§ä¸å˜é‡ï¼Œåœ¨ $F_p$ ä¸Šçš„è¶…å¥‡å¼‚æ›²çº¿ç”±äº j-invariant ä¸è¶³ä»¥åŒºåˆ†æ›²çº¿ $E$ å’Œå®ƒçš„äºŒæ¬¡æ‰­è½¬ $E&rsquo;$ ï¼Œæ‰€ä»¥ CSIDH ä¼šé€‰æ‹©ç”¨ $A$ æ¥ä½œä¸ºä¸€ç§æ ‡è¯†æ›²çº¿çš„æ–¹æ³•ã€‚è€Œ SIDH åœ¨ $F_{p^2}$ ä¸Š ï¼Œç”±äºå¼•å…¥äº† $i$ ï¼Œj-invariant èƒ½ä½œä¸ºæ›²çº¿çš„æ ‡è¯†ã€‚</p>
<pre tabindex="0"><code>sage: E.montgomery_model()
</code></pre><p><strong>Pairing</strong></p>
<p>ä»¤ $G_1,G_2,G_t$ ä¸ºç›¸åŒé˜¶çš„å¾ªç¯ç¾¤ï¼Œè®° $e:G_1\times G_2\rightarrow G_t$ æ˜¯ä»ç›´ç§¯ç¾¤ $G_1\times G_2$ åˆ° $G_t$ çš„æ˜ å°„ï¼Œå½“æ»¡è¶³ä¸‹è¿°æ€§è´¨æ—¶ç§°å…¶ä¸ºåŒçº¿æ€§æ˜ å°„ã€‚</p>
<ol>
<li>å¯¹äº $\forall\ U,V\in G_1,\ W\in G_2$ ï¼Œ$e(U+V,W)=e(U,W)\cdot e(V,W)$</li>
<li>å¯¹äº $\forall\ U\in G_1,\ V,W\in G_2,\ e(U,V+W)=e(U,V)\cdot e(U,W)$</li>
<li>å¯¹äº $\forall\ P\in G_1,P\ne O$ å­˜åœ¨ $Q\in G_2$ ä½¿å¾— $e(P,Q)\ne1$ ï¼Œå¯¹äº $Q\in G_2$ ç±»ä¼¼</li>
</ol>
<p>å¸¸è§çš„ Weil pairing å’Œ Tate pairing éƒ½æ˜¯æ¤­åœ†æ›²çº¿åŠ æ³•ç¾¤åˆ°æœ‰é™åŸŸä¹˜æ³•ç¾¤çš„æ˜ å°„ï¼Œå³ $G_1=G_2=E$ ï¼Œ$G_t=F_q$</p>
<h2 id="sidh">SIDH</h2>
<blockquote>
<p>SIDH (Supersingular Isogeny Diffie-Hellman) çš„å‡ ä¸ªå…³é”®å…ƒç´ ï¼šåŒæºã€è¶…å¥‡å¼‚ã€DHã€‚</p>
</blockquote>
<p>è¿™æ˜¯ä¸€ç§åŸºäºåŒæºçš„åœ¨è¶…å¥‡å¼‚æ›²çº¿ä¸Šç±»ä¼¼DHKEçš„å¯†ç å­¦åè®®ã€‚</p>
<p>åœ¨å¾—åˆ°å®Œæ•´çš„SIDHåè®®å‰æˆ‘ä»¬éœ€è¦ä¸º Alice å’Œ Bob åšä¸€äº›å‡†å¤‡ï¼Œ</p>
<p>Aliceï¼šèµ·å§‹æ›²çº¿ $E$ï¼Œ$E[2^a]$ ä¸Šçš„ torsion basis $P_A,Q_A$ï¼Œç§é’¥ $sk_a$</p>
<p>Bobï¼šèµ·å§‹æ›²çº¿ $E$ï¼Œ$E[3^b]$ ä¸Šçš„ torsion basis $P_B,Q_B$ï¼Œç§é’¥ $sk_b$</p>
<p>ä¸ºäº†ä¿è¯å­˜åœ¨ $2^a,3^b$ ä¸ºé˜¶çš„ç‚¹ï¼Œåœ¨ SIDH ä¸­å°†æ›²çº¿æ‰€åœ¨åŸŸè®¾ç½®ä¸º $F_{p^2}$ å…¶ä¸­ $p=2^a3^b-1$</p>
<p>åœ¨è¿™ä¸ªè®¾ç½®ä¸‹è¶…å¥‡å¼‚æ›²çº¿ $E$ çš„é˜¶ä¸º $(p+1)^2$ï¼Œé‚£ä¹ˆä¸Šè¿°çš„ torsion basis éƒ½æ˜¯å­˜åœ¨çš„ã€‚è€Œé€‰æ‹© $2^a,3^b$ è¿™æ ·çš„ç»“æ„æ˜¯å› ä¸ºè¿™æ ·ç®—çš„æ¯”è¾ƒå¿«ï¼Œè‹¥æ˜¯å¯¹äºä¸€èˆ¬çš„ $t|p+1$ï¼Œåœ¨ t è¾ƒå¤§æ—¶é€šè¿‡ VÃ©lu å…¬å¼ $O(t)$ æˆ–è€… âˆšÃ©lu $O(\sqrt{t})$ è®¡ç®— t-isogeny æ˜¯éå¸¸æ…¢çš„ã€‚ä½†æ˜¯å°ç´ æ•°çš„å¹‚è¿™ç§ç»“æ„èƒ½é€šè¿‡å¤åˆçš„æ–¹å¼è¿›è¡Œï¼Œæ¯”å¦‚ $2^a$-isogeny åªéœ€è¦ a æ¬¡ 2-isogeny å°±è¦å¿«å¾ˆå¤šã€‚</p>
<p>SIDH é¢ä¸´çš„ä¸»è¦æŠ€æœ¯éš¾ç‚¹æ˜¯è¶…å¥‡å¼‚æ›²çº¿çš„è‡ªåŒæ€ç¯éäº¤æ¢ï¼Œç»“åˆä¸Šé¢æ‰€è¯´çš„è¶…å¥‡å¼‚æ›²çº¿çš„å®šä¹‰ï¼Œå®é™…ä¸Šå°±æ˜¯è¯´ $F_{p^2}$ ä¸Šçš„æ›²çº¿è‡ªåŒæ€ç¯åŒæ„äºå››å…ƒä»£æ•°çš„æŸä¸ªæ•´ç¯ï¼Œä½†è¿™ä¸ªæ•´ç¯å¯¹ä¹˜æ³•æ˜¯ä¸€ä¸ªéäº¤æ¢çš„ç»“æ„ï¼Œè€Œ D-H ç±»å‹çš„åè®®éœ€è¦äº¤æ¢æ€§ã€‚</p>
<pre tabindex="0"><code>sage: p = 2**12 * 3**13 - 1
sage: Bpinf = QuaternionAlgebra(p)
sage: Î± = Bpinf.random_element()
sage: Î² = Bpinf.random_element()
sage: assert Î±*Î² != Î²*Î±
</code></pre><p>ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒSIDHåœ¨åè®®ä¸­å¼•å…¥äº†é¢å¤–è¾…åŠ©ç‚¹ï¼Œæ¥å¸®åŠ©åŒæ–¹æœ€åå¾—åˆ°ä¸€è‡´çš„å…±äº«å¯†é’¥ã€‚è¿™ä½¿å¾—SIDHå¹¶ä¸æ˜¯åŸºäºçº¯ç²¹çš„ isogeny path problem äº†ï¼Œä¹Ÿæ˜¯åé¢ SIDH è¢«æ”»ç ´çš„åŸå› ã€‚</p>
<p><strong>Protocol</strong></p>
<hr>
<p>Setup:</p>
<ul>
<li>$p=l_A^{e_A}l_B^{e_B}\cdot f-1$ï¼Œå›ºå®š $F_{p^2}$ ä¸Šçš„è¶…å¥‡å¼‚æ›²çº¿ $E$</li>
<li>Torsion bases $\set{P_a,Q_a}\in E[l_A^{e_A}]$ ï¼Œ$\set{P_b,Q_b}\in E[l_B^{e_B}]$</li>
</ul>
<pre tabindex="0"><code>sage: a, b = 216, 137
sage: p = 2**a*3**b-1
sage: F.&lt;i&gt; = GF(p**2, modulus=x**2+1)
sage: E = EllipticCurve(F, [1, 0])
sage: while True:
....:     Pa, Qa = [E.random_point()*3**b for _ in range(2)]
....:     if Pa.order() == Qa.order() == 2**a and Pa.weil_pairing(Qa, 2**a).mult
....: iplicative_order() == 2**a:
....:         break
sage: while True:
....:     Pb, Qb = [E.random_point()*2**a for _ in range(2)]
....:     if Pb.order() == Qb.order() == 3**b and Pb.weil_pairing(Qb, 3**b).mult
....: iplicative_order() == 3**b:
....:         break
</code></pre><p>Key Exchange:</p>
<ul>
<li>Alice é€‰æ‹©éšæœº $sk_a\in[0,l_A^{e_A}-1]$ï¼ŒBob é€‰æ‹©éšæœº $sk_b \in [0,l_B^{e_B}-1]$ï¼ŒAlice å°† $R=P_a+sk_a*Q_a$ ä½œä¸º Kernel è®¡ç®— $\phi_a:E\rightarrow E_a$ï¼ŒBobç±»ä¼¼é€šè¿‡ $S$ è®¡ç®—å‡º $\phi_b:E\rightarrow E_b$</li>
</ul>
<pre tabindex="0"><code>sage: ska = randint(0, 2**a-1)
sage: skb = randint(0, 3**b-1)
sage: R = Pa+ska*Qa
sage: S = Pb+skb*Qb
sage: Ï†a = E.isogeny(R, algorithm=&#34;factored&#34;)
sage: Ï†b = E.isogeny(S, algorithm=&#34;factored&#34;)
</code></pre><ul>
<li>Alice è®¡ç®— $\phi_a(P_b),\phi_a(Q_b)$ å¹¶å‘é€ç»™ Bobï¼ŒBob ç±»ä¼¼æ“ä½œã€‚</li>
</ul>
<pre tabindex="0"><code>sage: Ea = Ï†a.codomain()
sage: Pba, Qba = Ï†a(Pb), Ï†a(Qb)
sage: Eb = Ï†b.codomain()
sage: Pab, Qab = Ï†b(Pa), Ï†b(Qa)
</code></pre><ul>
<li>Alice å°† $R&rsquo;=\phi_b(R)=\phi_b(P_a)+sk_a*\phi_b(Q_a)$ ä½œä¸º Kernel è®¡ç®— $\phi_{ba}:E\rightarrow E_{ba}$ï¼ŒBobåŒç†ã€‚æœ€åç”±äº $E_{ab}\cong E_{ba}$ï¼Œè€ƒè™‘ j-invariant æœ€ç»ˆèƒ½åå•†åˆ°ä¸€è‡´çš„å¯†é’¥ $j(E_{ab})=j(E_{ba})$</li>
</ul>
<pre tabindex="0"><code>sage: Rb = Pab+ska*Qab
sage: jba = Eb.isogeny(Rb, algorithm=&#34;factored&#34;).codomain().j_invariant()
sage: Sa = Pba+skb*Qba
sage: jab = Ea.isogeny(Sa, algorithm=&#34;factored&#34;).codomain().j_invariant()
sage: assert jab == jba
</code></pre><hr>
<p>å›¾ç¤ºå¦‚ä¸‹ï¼š</p>
<p>ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€<img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241107111825700.png" alt="image-20241107111825700"></p>
<p><strong>Security</strong></p>
<p>SIDH åŸºäºçš„å®‰å…¨æ€§å¯ä»¥è½¬æ¢ä¸ºä¸‹é¢çš„å‘½é¢˜</p>
<p>SupperSingular Computational Diffie-Hellman Problem(SSCDH)ï¼šç»™å®šæ›²çº¿ $E_a,E_b$ ä»¥åŠä¸€äº›ç‚¹ $\phi_a(P_b),\phi_a(Q_b),\phi_b(P_a),\phi_b(Q_a)$ ï¼Œè®¡ç®— $E/\langle P_a+[sk_a]Q_a,P_b+[sk_b]Q_b\rangle$ çš„ j-invariantã€‚</p>
<p>Isogeny Path Problemï¼šç»™å®šæ›²çº¿ $E,E&rsquo;$ï¼Œè®¡ç®— $E$ åˆ° $E&rsquo;$ ä¹‹é—´çš„æ˜ å°„ã€‚</p>
<p>å®é™…ä¸Šå°† SSCDH æ¢æˆä¸‹é¢è¿™ç§è¡¨è¿°æ–¹æ¡ˆåªæ˜¯ç»™å‡ºäº†é¢å¤–çš„ $E,E&rsquo;$ é—´æ˜ å°„çš„ä¸¤ç»„åƒåŸåƒå¯¹ã€‚</p>
<p>ç»“è®ºå°±æ˜¯è¿™æ ·éå¸¸ä¸å®‰å…¨ï¼Œä»ä¹‹å‰çš„ä¸€ç³»åˆ— torsion point attack åˆ°ç°åœ¨ key recover attack éƒ½æ˜¯åˆ©ç”¨äº†æ‰€ç»™çš„è¾…åŠ©ç‚¹ä¿¡æ¯ã€‚</p>
<p>Castryck-Decru Key Recovery Attack on SIDH <a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">Repo</a></p>
<h2 id="csidh">CSIDH</h2>
<blockquote>
<p>CSIDH ä¸­çš„ C æŒ‡çš„æ˜¯ Commutativeï¼Œä¸åŒäº SIDH éœ€è¦å¼•å…¥è¾…åŠ©ç‚¹ï¼Œè¿™é‡Œçš„ç»“æ„æœ¬èº«å°±æ˜¯äº¤æ¢çš„ã€‚ğŸï¸</p>
</blockquote>
<p>é¦–å…ˆéœ€è¦å…ˆå»ºç«‹å‡ ä¸ªä¼šé¢‘ç¹å‡ºç°çš„æ•°å­¦åè¯ç›´è§‰ï¼Œ</p>
<p>$End(E)$: $E$ å¯¹åº”çš„è‡ªåŒæ€ç¯ï¼Œä¹Ÿå°±æ˜¯åŸåƒå’Œåƒéƒ½æ˜¯ $E$ çš„åŒæ€æ˜ å°„çš„ä¸€ä¸ªé›†åˆ</p>
<p>$\mathcal{O}$ (Order): å¯ä»¥ç®€å•ç†è§£ä¸ºä»£æ•°æ•°åŸŸä¸Šçš„å­ç¯ï¼Œç±»ä¼¼é«˜æ–¯æ•´ç¯ $\mathbb{Z}[\sqrt{-1}]$ è¿™ç§å°±å¯ä»¥å« Order</p>
<p>$\mathcal{Ell}(\mathcal{O},\pi)$: æ‰€æœ‰è‡ªåŒæ€ç¯ä¸ $\mathcal{O}$ åŒæ„çš„æ›²çº¿ç±»ï¼Œ$\pi$ æŒ‡ Frobenius æ˜ å°„</p>
<p>$cl(\mathcal{O})$ï¼šç†æƒ³ç±»ç¾¤ï¼Œi.e. $\mathcal{O}$ ä¸­ç†æƒ³é›†å•†å»ç­‰ä»·å…³ç³»ï¼Œç›´è§‚ä¸Šæ„Ÿè§‰æ˜¯å¯¹ $\mathcal{O}$ åšäº†ä¸€ä¸ªåˆ†ç±»</p>
<p>$[\mathfrak{l}]\in cl(\mathcal{O})$: ç†æƒ³ç±»ï¼ŒåŒ…å«äº†ä¸€äº›ç†æƒ³ï¼Œè¿™äº›ç†æƒ³ä½œç”¨åœ¨ $\mathcal{Ell}(\mathcal{O},\pi)$ ä¸­çš„æ›²çº¿ååƒåŒæ„</p>
<p>ä¸‹é¢æ¥çœ‹ CSIDH ä¸­æœ€é‡è¦çš„æ“ä½œ  <em>group action</em></p>
<p>å®šä¹‰ï¼š$\mathcal{O}$ æ˜¯è™šäºŒæ¬¡åŸŸä¸Šçš„ä¸€ä¸ªæ•´ç¯ï¼Œä¸” $\pi\in\mathcal{O}$ï¼Œ$\mathcal{Ell}_p(\mathcal{O},\pi)$ éç©ºã€‚é‚£ä¹ˆç†æƒ³ç±»ç¾¤ $cl(\mathcal{O})$ ä½œç”¨åœ¨ $\mathcal{Ell}_p(\mathcal{O},\pi)$ ä¸Šè‡ªç”±å¯è¿ï¼Œå…¶ä½œç”¨è¿‡ç¨‹å¯è¡¨è¿°ä¸º
$$
cl(\mathcal{O})\times \mathcal{Ell}_p(\mathcal{O},\pi)\rightarrow \mathcal{Ell}_p(\mathcal{O},\pi):\ ([\mathfrak{a}],E)\mapsto E/[\mathfrak{a}]
$$
é‚£è¿™ä¸ªè¿‡ç¨‹æ˜¯æ€ä¹ˆå’ŒåŒæºå…³è”èµ·æ¥çš„å‘¢ï¼Œä¸‹é¢æ›´ç›´è§‚åœ°ç†è§£ $([\mathfrak{a}],E)$ çš„è¿‡ç¨‹ï¼Œä¸€å±‚å±‚æ¥ç¿»è¯‘ï¼Œè€ƒè™‘ $\mathfrak{a}$ å¯¹ $E$ çš„ä½œç”¨ï¼Œå› ä¸º $\mathfrak{a}$ æ˜¯ $\mathcal{O}$ çš„ç†æƒ³ï¼Œè€Œ $\mathcal{O}$ åŒæ„äº $\mathcal{Ell}$ ä¸­å…ƒç´ çš„è‡ªåŒæ€ç¯ï¼Œæ‰€ä»¥ $\mathfrak{a}$ ä¹Ÿå¯ä»¥çœ‹æˆè‡ªåŒæ€ç¯çš„ç†æƒ³ï¼Œå…¶ä¸­åŒ…å«äº†ä¸€äº›è‡ªåŒæ€æ˜ å°„ï¼Œå–å…¶ä¸­æ¯ä¸ªè‡ªåŒæ€æ˜ å°„æ ¸çš„äº¤èƒ½å¾—åˆ°ä¸€äº›ç‚¹çš„é›†åˆè®°ä¸º $\widetilde{\mathfrak{a}}$ï¼Œè€Œ $E/[\mathfrak{a}]$ ä¹Ÿå°±æ˜¯ $E/\widetilde{\mathfrak{a}}$ ã€‚</p>
<p>é‚£ä¹ˆè¿™ç§è§‚ç‚¹ä¸‹å°±æ¯”è¾ƒæ–¹ä¾¿ç†è§£ CSIDH çš„äº¤æ¢æ€§äº†ï¼ŒCSIDHçš„äº¤æ¢æ€§å’Œç†æƒ³ç±»ç¾¤çš„äº¤æ¢æ€§ç›´æ¥æŒ‚é’©ï¼Œåªéœ€è¦è¯´æ˜ $[\mathfrak{a}][\mathfrak{b}]=[\mathfrak{b}][\mathfrak{a}]$ï¼Œä¹Ÿå°±æ˜¯ $\mathcal{O}$ ä¸Šå…ƒç´ æ˜¯å¦å…·æœ‰äº¤æ¢æ€§ï¼Œå¯¹äº CSIDH åªè¦éªŒè¯å¯¹åº”çš„ $\mathbb{Z}[\pi]$ ä¹Ÿå°±æ˜¯ $\mathbb{Z}[\sqrt{-p}]$ å°±è¡Œã€‚</p>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: K.&lt;i&gt; = NumberField(x^2+p)
sage: O = K.order([1, i])
sage: Î± = O.random_element()
sage: Î² = O.random_element()
sage: assert Î±*Î² == Î²*Î±
</code></pre><p>è¿™æ ·ç†è§£çš„è¯ï¼ŒCSIDH çš„ç»“æ„å’Œå¸¸è§çš„ Dlog çš„ç»“æ„æ˜¯å¯ä»¥è”æƒ³èµ·æ¥çš„ï¼Œå› ä¸ºéƒ½æ˜¯äº¤æ¢çš„ç»“æ„ï¼Œä½†æ˜¯ç”±äº Shor ç®—æ³•çš„å‡ºç° Dlog å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´æ±‚è§£ï¼Œä½†æ˜¯å¯¹äº CSIDH åªèƒ½ç®—æ˜¯ Hidden shift problemï¼Œå¯¹å…¶æœ€å¥½çš„æ”»å‡»æ˜¯ Kuperberg çš„äºšæŒ‡æ•°æ—¶é—´æ”»å‡»ã€‚</p>
<p><strong>Protocol</strong></p>
<hr>
<p>Setup:</p>
<ul>
<li>é€‰æ‹© $p=4\cdot l_1l_2\dots l_k-1$ ï¼Œå…¶ä¸­ $l_i$ ä¸ºå°å¥‡ç´ æ•°ï¼Œè®¾ç½®ä¸€ä¸ª $F_p$ ä¸Šèµ·å§‹è¶…å¥‡å¼‚æ›²çº¿ $E:y^2=x^3+x$ï¼Œè‡ªåŒæ€ç¯ä¸º $\mathbb{Z}[\sqrt{-p}]$</li>
</ul>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: F = GF(p, &#39;i&#39;)
</code></pre><ul>
<li>Alice é€‰æ‹©ç§é’¥ $[\mathfrak{a}]$ ï¼ŒBob é€‰æ‹©ç§é’¥ $[\mathfrak{b}]$ ï¼Œç”±ä¸Šé¢æåˆ°çš„ $[\mathfrak{a}]$ ä¸åŒæºè®¡ç®—çš„å…³ç³»ï¼Œå®é™…ä¸Š $[\mathfrak{a}]$ å¯ä»¥çœ‹æˆåšå“ªäº› $l_i$-isogeny ã€‚</li>
</ul>
<pre tabindex="0"><code>sage: priv1 = [randint(-3, 3) for _ in range(len(ells))]
sage: priv2 = [randint(-3, 3) for _ in range(len(ells))]
</code></pre><p>Key Exchange</p>
<pre tabindex="0"><code>sage: def csidh(A, priv):
....:     E = EllipticCurve(F, [0, A, 0, 1, 0])
....:     for sgn in [1, -1]:
....:         for e, ell in zip(priv, ells):
....:             for i in range(sgn * e):
....:                 while not (P := (p + 1) // ell * E.random_element()):
....:                     pass
....:                 P.set_order(ell)
....:                 E = E.isogeny_codomain(P)
....:         E = E.quadratic_twist()
....:     return E.montgomery_model().a2()
</code></pre><ul>
<li>åˆ†åˆ«è®¡ç®— $E_a=[\mathfrak{a}]\star E,E_b=[\mathfrak{b}]\star E$</li>
</ul>
<pre tabindex="0"><code>sage: Ea = csidh(0, priv1)
sage: Eb = csidh(0, priv2)
</code></pre><ul>
<li>åŒæ–¹æ ¹æ®å¯¹æ–¹ä¼ æ¥çš„ $E_b$ æˆ– $E_a$ è®¡ç®— $E_{ba},E_{ab}$ ï¼Œåå•†å‡ºä¸€è‡´çš„å¯†é’¥ $A(E_{ba})=A(E_{ab})$</li>
</ul>
<pre tabindex="0"><code>sage: assert csidh(Ea, priv2) == csidh(Eb, priv1)
</code></pre><hr>
<p>å›¾ç¤ºå¦‚ä¸‹ï¼š</p>
<p>ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€<img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241108114220253.png" alt="image-20241108114220253"></p>
<p><strong>Security</strong></p>
<p>CSIDH çš„å®‰å…¨æ€§ç”± CSSCDH çš„å¼ºåº¦å†³å®š</p>
<p>CSSCDHï¼šè®° $p,E$ å‡ä¸º CSIDH ä¸­çš„å‚æ•°ï¼Œç»™å‡º $E,[\mathfrak{a}]\star E,[\mathfrak{b}]\star E$ è®¡ç®— $[\mathfrak{a}]\star [\mathfrak{b}]\star E$ æ˜¯å›°éš¾çš„ï¼Œå…¶ä¸­ $\mathfrak{a},\mathfrak{b}$ ä¸º $\mathcal{O}$ ä¸­çš„éšæœºå…ƒç´ ã€‚</p>
<p>ç”±äº CSIDH ä¸ SIDH ä¸åŒï¼Œä¸éœ€è¦è¾…åŠ©ç‚¹çš„ä»‹å…¥ï¼Œè¿™ä¹Ÿä½¿å¾—å…¶å¯ä»¥å…ç–«å¤§å¤šé’ˆå¯¹ SIDH çš„åŸºäºç»™å‡ºæ‰­è½¬ç‚¹åƒçš„æ”»å‡»ã€‚</p>
<h2 id="challenges">Challenges</h2>
<table>
<thead>
<tr>
<th style="text-align:center">CTF</th>
<th style="text-align:center">Challenge</th>
<th style="text-align:center">Difficulty</th>
<th style="text-align:center">Overview</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N1junior 2024</td>
<td style="text-align:center">IEV@L</td>
<td style="text-align:center">â­</td>
<td style="text-align:center">ä¸­é—´ç›¸é‡ï¼Œå¤–åŠ ä¸€ç‚¹ç®€å•pyjail</td>
</tr>
<tr>
<td style="text-align:center">M0leconCTF 2022</td>
<td style="text-align:center">SIDHalf</td>
<td style="text-align:center">â­</td>
<td style="text-align:center">Weil pairingåœ¨åŒæºä¸‹çš„åº”ç”¨</td>
</tr>
<tr>
<td style="text-align:center">DiceCTF 2023</td>
<td style="text-align:center">seaside</td>
<td style="text-align:center">â­</td>
<td style="text-align:center">CSIDH äºŒæ¬¡æ‰­è½¬</td>
</tr>
<tr>
<td style="text-align:center">jqctf-quals 2024</td>
<td style="text-align:center">BabyOracle2</td>
<td style="text-align:center">â­â­</td>
<td style="text-align:center">GPST Attack</td>
</tr>
<tr>
<td style="text-align:center">RCTF 2022</td>
<td style="text-align:center">S2DH</td>
<td style="text-align:center">â­â­</td>
<td style="text-align:center">Castryck-Decru Attackï¼Œæœ‰ç°æˆçš„repoã€‚éœ€è¦æ ¹æ®è®ºæ–‡å†…å®¹ä¿®æ”¹èµ·å§‹æ›²çº¿çš„è‡ªåŒæ€ç¯æ±‚æ³•ã€‚</td>
</tr>
<tr>
<td style="text-align:center">jqctf-quals 2024</td>
<td style="text-align:center">S2DH+</td>
<td style="text-align:center">â­â­â­</td>
<td style="text-align:center">èµ·å§‹æ›²çº¿æœ‰å·²çŸ¥çš„è‡ªåŒæ€ç¯ï¼Œå‚è€ƒ Petit&rsquo;s Attack å¤§è‡´æ€è·¯</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<p>[1] CSIDH: An Eï¬ƒcient Post-Quantum Commutative Group Action <a href="https://eprint.iacr.org/2018/383.pdf">â†©</a></p>
<p>[2] Supersingular isogeny key exchange for beginners <a href="https://eprint.iacr.org/2019/1321.pdf">â†©</a></p>
<p>[3] Mathematics of Isogeny Based Cryptography <a href="https://arxiv.org/pdf/1711.04062">â†©</a></p>
<p>[4] CSIDHæ–¹æ¡ˆçŸ­è¯¾ï¼ˆæ²™é¾™ï¼‰<a href="https://su1yu4n.github.io/2024/10/15/CSIDH%E6%96%B9%E6%A1%88%E5%88%86%E4%BA%AB/">â†©</a></p>
<p>[5] Divisors and Pairings <a href="https://klwu.co/knowledge/ec-basics-3-divisors/">â†©</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>N1CTF2021</title>
      <link>https://h45h.fun/posts/n1ctf2021/</link>
      <pubDate>Tue, 12 Dec 2023 23:26:07 +0800</pubDate>
      
      <guid>https://h45h.fun/posts/n1ctf2021/</guid>
      <description>checkin from Crypto.Util.number import * from secret import flag p = getPrime(512) q = getPrime(512) n = p*q x = 2021*p&#43;1120*q h = (inverse(x,n)&#43;x)%n e = 65537 c = pow(bytes_to_long(flag), e, n) print(&amp;#39;n =&amp;#39;, n) print(&amp;#39;c =&amp;#39;, c) print(&amp;#39;h =&amp;#39;, h) print(&amp;#39;p0 =&amp;#39;, p &amp;gt;&amp;gt; 490) # n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793 # c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833 # h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806 # p0 = 4055618 $h=\frac{1}{x}&#43;x$
$\Rightarrow x^2-h\cdot x&#43;1(mod\ n)$
We can get high bits of q through the known p high bits.</description>
      <content:encoded><![CDATA[<h2 id="checkin">checkin</h2>
<pre tabindex="0"><code>from Crypto.Util.number import *
from secret import flag
 
p = getPrime(512)
q = getPrime(512)
n = p*q
x = 2021*p+1120*q
h = (inverse(x,n)+x)%n
e = 65537
c = pow(bytes_to_long(flag), e, n)
 
print(&#39;n =&#39;, n)
print(&#39;c =&#39;, c)
print(&#39;h =&#39;, h)
print(&#39;p0 =&#39;, p &gt;&gt; 490)
 
# n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793
# c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833
# h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806
# p0 = 4055618
</code></pre><p>$h=\frac{1}{x}+x$</p>
<p>$\Rightarrow x^2-h\cdot x+1(mod\ n)$</p>
<p>We can get high bits of q through the known p high bits.</p>
<p>$x=2021\cdot p+1120\cdot q=(2021\cdot(2^{490}\cdot p_0+p_1)+1120\cdot(2^{490}\cdot q_0+q_1))$</p>
<p>The unknown part of x is less than 501 bits</p>
<p><code>small_roots</code> can solve this with <code>epsilon=0.02</code></p>
<p>It&rsquo;s higher than the theoretical bound, may be LLL sometimes do better.</p>
<pre tabindex="0"><code>n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793
c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833
h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806
p0 = 4055618
q0 = None

head = n&gt;&gt;(1024-22)
for i in range(2**22):
    if (i*p0)&gt;&gt;22 == head:
        q0 = i
        break

PR.&lt;x&gt; = PolynomialRing(Zmod(n))
g = x+2021*2^490*p0+1120*2^490*q0
f = g^2-h*g+1

root = ZZ(f.small_roots(X=2^500, beta=1, epsilon=0.02)[0])
x0 = root+2021*2^490*p0+1120*2^490*q0
diff = isqrt(x0^2-4*2021*1120*n)
p = (x0+diff)//4042
q = (x0-diff)//2240
phi = (p-1)*(q-1)
d = inverse_mod(0x10001, phi)
m = pow(c, d, n)
print(bytes.fromhex(hex(m)[2:]))
</code></pre><h2 id="n1token1">n1token1</h2>
<pre tabindex="0"><code>from Crypto.Util.number import *
import random
from secret import flag
 
def gettoken(c):
    X = 0
    while ((pow(X, (p-1)//2, p)!=1) or (pow(X, (q-1)//2, q)!=1)):
        X = 1
        while X.bit_length() &lt; 920:
            X *= random.choice(primes)
    xp = pow(X, (p + 1)//4, p)
    xq = pow(X, (q + 1)//4, q)
    xp = random.choice([xp,-xp%p])
    xq = random.choice([xq,-xq%q])
    x = c * (xp*inverse(q,p)*q + xq*inverse(p,q)*p) % n
    return x
 
def getmyPrime(nbits):
    p = getPrime(nbits)
    while(p%4==1):
        p = getPrime(nbits)
    return p
 
primes = random.sample(sieve_base, 920)
p = getmyPrime(512)
q = getmyPrime(512)
e = 65537
n = p*q
c = pow(bytes_to_long(flag), e, n)
 
with open(&#34;output.txt&#34;, &#34;w&#34;)as f:
    f.write(&#34;n = &#34; + str(n) + &#34;\n&#34;)
    for i in range(920):
        f.write(&#34;Token #&#34;+str(i+1)+&#39;: &#39;+str(gettoken(c))+&#39;\n&#39;)
</code></pre><p>The token generating as follow,</p>
<p>$tk_i = c\cdot \sqrt{X_i}(mod\ n)$</p>
<p>$\Rightarrow tk_i^2\cdot(c^{-2})=X_i(mod\ n)$ Where $X&lt;2^{940}$</p>
<p>So we can solve this hidden number problem to recover $X_i$.</p>
<p>$\Rightarrow tk_0^2\cdot (tk_i^2)^{-1}=X_0\cdot X_i^{-1}(mod\ n)$</p>
<p>Rewriting the $X_i$ with primes&rsquo; exponent, and solve the kernel of exponent matrix in $F_2$ (only care parity)</p>
<p>Finally, we can construct $a^2=b^2(mod\ n)$, it&rsquo;s probably get the factors of n.</p>
<pre tabindex="0"><code>from Crypto.Util.number import *
from functools import reduce

f = open(&#39;output.txt&#39;, &#39;r&#39;)
f.read(4)
n = int(f.readline())
tk = []
for _ in range(920):
    tk_ = f.readline()
    st = tk_.index(&#39;:&#39;)
    tk.append(int(tk_[st+1:]))

def solver_hnp(s):
    L = matrix(QQ, 101, 101)
    L[0, 0] = 2^(940-1024)
    for _ in range(100):
        L[0, _+1] = s[_]**2%n
        L[_+1, _+1] = n
    basis = L.LLL()[1]
    g = reduce(GCD, basis[1:])
    c_ = basis[0]*2^(1024-940)//g
    return c_

c_ = solver_hnp(tk[:100])
if (c_*tk[0]**2)%n &gt; 2^940:
    c_ = -c_

X = []
for tk_ in tk:
    X.append((tk_**2*(c_)%n))

primes = set()
for x in X:
    facs = list(factor(x))
    for item in facs:
        primes.add(item[0])
        
primes = list(primes)
ch = []
for x in X:
    u = [0]*920
    facs = list(factor(x))
    for item in facs:
        u[primes.index(item[0])] = item[1]
    ch.append(u)
    
std = vector(ZZ, ch[0])
Ch = []
for i in range(1, len(ch)):
    Ch.append(std-vector(ch[i]))
    
A = matrix(Zmod(2), Ch)
ker = vector(ZZ, list(A.left_kernel().matrix()[0]))
res = ker*matrix(ZZ, Ch)
a = 1; b = 1
for i in range(len(ker)):
    if ker[i]:
        a *= tk[0]
        b *= tk[i+1]

for i in range(len(res)):
    if res[i] &gt; 0:
        b *= pow(primes[i], res[i]//2, n)
    else:
        a *= pow(primes[i], abs(res[i])//2, n)

p = GCD(a+b, n)
q = n//p
Fp = GF(p)
Fq = GF(q)
phi = (p-1)*(q-1)
d = inverse_mod(0x10001, phi)
c2 = inverse_mod(X[0], n)*tk[0]**2%n
m2 = pow(c2, d, n)
mp = Fp(m2).nth_root(2, all=True)
mq = Fq(m2).nth_root(2, all=True)

for i in mp:
    for j in mq:
        m = crt([int(i), int(j)], [p, q])
        print(long_to_bytes(m))
</code></pre><h2 id="n1token2">n1token2</h2>
<pre tabindex="0"><code>import random
from secret import flag
 
assert FLAG.startswith(&#39;n1ctf{&#39;)
assert FLAG.endswith(&#39;}&#39;)
SECRET = bytes.fromhex(FLAG[6:-1])
assert len(SECRET) == 16
 
p = 251
 
e = [1, 20, 113, 149, 219]
 
y = b&#39;&#39; 
for x in range(1, p):
    coeff = [random.choice(e)] + list(SECRET)
    y += bytes([sum(c * pow(x, i, p) for i, c in enumerate(coeff)) % p])
    
print(f&#39;Token: {y.hex()}&#39;)
</code></pre><p>We can use the prod idea to solve multiple choices problem</p>
<p>assume $F(x)=\sum_{i=1}\limits^{16}a_ix^i$</p>
<p>So the relation can be write as follow,</p>
<p>$\prod_{i=0}\limits^4(F(x_j)+e_i-y_j)=0$</p>
<p>$a_0+a_1\cdot F(x_j)+a_2\cdot F^2(x_j)+a_3\cdot F^3(x_j)+a_4\cdot F^4(x_j)+a_5\cdot F^5(x_j)=0$</p>
<p>Considering $F^j(x)$ as independent polynomial, there are total 245 unknow coefficients.</p>
<p>With 250 tokens, solving the matrix to recover all coefficient.</p>
<pre tabindex="0"><code>token = &#39;ae47d3533e10b444374ebd35f578103f94c327b5959f4580b0dc4701d089f22c282acfed2626bd9ced919547dacc96c18595468952cbedbcf518b5ec0fbc0437ea8e3bd77c5f01f73b555cc97a382df1ce28b4af7f9a5ab9c47e055044f47463c4f33bebdd4d6965599c71720b5a549a8246cb200dc4e2dccfc4765c0ac266a8a5385172aa47f834db737a3bcc725ae5a1ec8b76d1ca4800da10450b04543377efa5428584efdfdf55282e0e4410ae7848a0217a7d66f2d6c06c846a4755867dbdf61c70646f67debf44839a342e5f64e3abd2c9f5b66656edc8004cea987503793f7e07e3b60af4852e03177cae1e8ee605aab76d3a70df4e1e&#39;
p = 251
e = [1, 20, 113, 149, 219]
A = []
v = []
Z.&lt;x&gt; = PolynomialRing(Zmod(p))
for i in range(0, len(token), 2):
    tk = int(token[i:i+2], 16)
    a = []
    for e_ in e:
        a.append(e_-tk)
    f = (x+a[0])*(x+a[1])*(x+a[2])*(x+a[3])*(x+a[4])
    coeff = (list(f))[::-1]
    x0 = i//2+1
    u = []
    for _ in range(81):
        u.append(coeff[0]*x0^_)
    for _ in range(65):
        u.append(coeff[1]*x0^_)
    for _ in range(49):
        u.append(coeff[2]*x0^_)
    for _ in range(33):
        u.append(coeff[3]*x0^_)
    for _ in range(17):
        u.append(coeff[4]*x0^_)
    v.append(-coeff[-1])
    A.append(u)
    
A = matrix(Zmod(p), A)
v = vector(Zmod(p), v)
sol = A.solve_right(v)
secret = bytes(sol[-16:]).hex()
print(secret)
</code></pre>]]></content:encoded>
    </item>
    
  </channel>
</rss>