<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on echo :)</title>
    <link>https://h45h.fun/posts/</link>
    <description>Recent content in Posts on echo :)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Dec 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://h45h.fun/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2024 Summary</title>
      <link>https://h45h.fun/posts/2024_summary/</link>
      <pubDate>Tue, 31 Dec 2024 08:00:00 +0800</pubDate>
      
      <guid>https://h45h.fun/posts/2024_summary/</guid>
      <description>由于平时没有记录的习惯，所以是根据自己的印象整理一下今年干了什么.jpg。可以说是2024年度流水账💦&amp;hellip;
今年的一二月份寒假例行在家过年摸🐠，然后在准备一些保研的事情，应该是非常早了，本来想着等下学期就行，但是学长说绩点不高的话提前联系会比较好。做的事情基本就是过过论文，看下方向是不是还合适。由于兴趣的原因比较接受密码学相关的，所以除了本校外信工所、浙大、上交的老师都看了下。信工所、上交做分析的比较多，浙大这边偏应用一点。然后就是联系导师，表达一下对方向的兴趣，看看后续联系什么的。感觉也是运气非常好了，三月份的时候就找到了合适的老师，后面就是时不时看看相关的论文。最神奇的是因为想找导师的时候选择广一点临时学了一手 Code Based 相关的内容，结果发现老师刚好也是有这个需求，后面也是持续发挥作用，不仅大三下有相关课程，CTF 出题也贡献了一些点子。
之后在三四月的时候拉着同学参加了一手密码数学挑战赛，大一的时候就觉得这个比赛很硬核，大二的时候看了下选题，但因为时间原因也没咋研究，这次正好看到了比较合适的题目打算试试，甚至决赛还是在山大办。三个多月的初赛，几乎只打了三四天就把第一部分所有题目过掉了，但是第二部分就很抽象，也不知道到底想考什么，极其模糊的描述，感觉可以归类为猜谜题。我想着500分已经拿了400，第二部分随便弄一下应该就行，然后瞎找了手规律就下线了。最后也是进了决赛，后面得知分数线也就400刚好就是只做完第一部分的分数XD。
最后期末周前打了 CryptoCTF，因为接触 CTF 的这几年几乎年年都打一下，甚至去年和 Zima 他们还AK了，虽然最后是十几名，因为太简单了大部分队伍都打完了。然后今年 Zima 也喊了我还有小鸡块、yolbby 和其他的一些师傅，正好 Nu1L 这边没打，Hermes 在旅游，于是拉上了 leukocyte 一起组了个 cyberCryer 去玩。因为感觉晚上脑子不是很清楚做不来题目，第一天晚上很早就睡了，然后大概是七点钟闹钟起来继续看，前 1/2 的时间大伙几乎都是在过一些简单题，什么比较常规的密码学和数学题。甚至今年还遇到了IMO的函数方程，没绷住，正好高中的时候还刷过类似的题目。大概是最后的一半时间我们做的还剩三个 tough 还有一个 0 解的 Medium，然后选了一个合适的就开始推。应该是在结束前几个小时小鸡块挂的 yafu 花了11个小时分解了4个128的乘积，谁能想到呢，CCTF 真有蛮力分解的题还放在了 tough 里。然后就是我搞了一下午的多变量，只有大概的思路，然后提议了一手要找论文，leu秒搜到了，我大致过了下论文逻辑基本就确定了，准备把现成的poc连上去打，写一半的时候我突然想通了，一直有个直接能bypass的逻辑没理清楚。做完之前 yolbby 和小鸡块也过掉了最后一个 tough，那就只剩下 0 解 Medium 。最后四支队伍也都是差这个题，手速原因非常幸运地拿到了🥈。
几乎是在期末周的时间，和 HASHTEAM 进行了最后一把 CISCN，去的南京。结束了打了三年的 CISCN，虽然三年都没进决赛，但是感觉后面学弟们的机会还是比较大，氛围也是逐渐好了起来🎉。预计这之后应该能取得不错的成绩。
六月份考完期末就是夏令营的时间，也没多想，因为很早联系好了老师，投了的浙大、上交、信工所也全都入营了，然后浙大这边的周期比较长，是实打实的做项目而不是纯粹的面试，感觉非常合适，就完全没管其他的学校了。接着就是在 ZJU 的快乐暑假，由于我们这级保研政策得到保研前公布，而大三一整个摸鱼导致绩点往下掉了快十名，需要拿到竞赛加分才行，所以那个时候还挺折磨的虽然说是感觉能拿到。但是真正在 ZJU 开始夏令营之后几乎是完全忘记了这回事，最为神奇的是组里面的一些学长因为打 CTF 的原因发现之前甚至都一起打过比赛甚至认识但是只知道 ID。所以融入的算是非常快了，基本在为期一个月的夏令营时间都是过的很开心，上下午捣鼓 idea，晚上和大家打球，非常 nice。中间去玉泉校区那边逛了逛，确实是非常有年代那边，环境也很好，但是住宿啥的就比不上水博园这边。
夏令营结束 StrawHat 在杭州这边打 DEFCON，我觉得应该不会有密码，但是就在玉泉附近，所以我还是过去了，最后碰到了比较好玩的 Re/Crypto AWD，也是不亏。大致内容就是防守部分写一个64位的小型类哈希方案，然后攻击部分就是分析其他队伍的源码，然后求解。最开始玩的比较开心，因为刚上来大家传的一些防守都非常 trivial 。但是后面就变得阴间起来了，一些队伍开发了自动化的更改参数和少量代码逻辑，再加上这种类似对称的结构很难短时间分析出来，后面就基本没啥能干的活了。最后 StrawHat👒 又拿了第五。
打完之后回学校参加了密码数学挑战赛的决赛，由于大半个暑假基本都在夏令营这边也没怎么做后续的优化，后面微调了下第二部分的逻辑就上交了。这次决赛来了非常多的 CTF 选手，比赛前的晚上 Deebato 喊大家一起吃了个饭，也是大型网友面基了。这比赛也算是我第一次上台答辩，属于是完全没经验。之前比赛的答辩纯靠队友带，给我整的很头疼。然后就尴尬了，本着评委老师应该只关注内容不会关注形式的心理，进行了一手稿的念，念完之后就感觉我真的很抽象。后面问了下其他人发现都是脱稿😭。答辩完大伙又一起去了周边的烧烤，开始吐槽神奇的牛顿多面体，也聊了很多，具体聊了啥我也忘了☹️。最后只拿了三等奖，也是符合预期毕竟花的时间有点少。总的来说还行，体验了一把，希望之后还能再玩玩，如果题目合适的话🤔。</description>
      <content:encoded><![CDATA[<p>　　由于平时没有记录的习惯，所以是根据自己的印象整理一下今年干了什么.jpg。可以说是2024年度流水账💦&hellip;</p>
<p>　　今年的一二月份寒假例行在家过年摸🐠，然后在准备一些保研的事情，应该是非常早了，本来想着等下学期就行，但是学长说绩点不高的话提前联系会比较好。做的事情基本就是过过论文，看下方向是不是还合适。由于兴趣的原因比较接受密码学相关的，所以除了本校外信工所、浙大、上交的老师都看了下。信工所、上交做分析的比较多，浙大这边偏应用一点。然后就是联系导师，表达一下对方向的兴趣，看看后续联系什么的。感觉也是运气非常好了，三月份的时候就找到了合适的老师，后面就是时不时看看相关的论文。最神奇的是因为想找导师的时候选择广一点临时学了一手 Code Based 相关的内容，结果发现老师刚好也是有这个需求，后面也是持续发挥作用，不仅大三下有相关课程，CTF 出题也贡献了一些点子。</p>
<p>　　之后在三四月的时候拉着同学参加了一手密码数学挑战赛，大一的时候就觉得这个比赛很硬核，大二的时候看了下选题，但因为时间原因也没咋研究，这次正好看到了比较合适的题目打算试试，甚至决赛还是在山大办。三个多月的初赛，几乎只打了三四天就把第一部分所有题目过掉了，但是第二部分就很抽象，也不知道到底想考什么，极其模糊的描述，感觉可以归类为猜谜题。我想着500分已经拿了400，第二部分随便弄一下应该就行，然后瞎找了手规律就下线了。最后也是进了决赛，后面得知分数线也就400刚好就是只做完第一部分的分数XD。</p>
<p>　　最后期末周前打了 CryptoCTF，因为接触 CTF 的这几年几乎年年都打一下，甚至去年和 Zima 他们还AK了，虽然最后是十几名，因为太简单了大部分队伍都打完了。然后今年 Zima 也喊了我还有小鸡块、yolbby 和其他的一些师傅，正好 Nu1L 这边没打，Hermes 在旅游，于是拉上了 leukocyte 一起组了个 cyberCryer 去玩。因为感觉晚上脑子不是很清楚做不来题目，第一天晚上很早就睡了，然后大概是七点钟闹钟起来继续看，前 1/2 的时间大伙几乎都是在过一些简单题，什么比较常规的密码学和数学题。甚至今年还遇到了IMO的函数方程，没绷住，正好高中的时候还刷过类似的题目。大概是最后的一半时间我们做的还剩三个 tough 还有一个 0 解的 Medium，然后选了一个合适的就开始推。应该是在结束前几个小时小鸡块挂的 yafu 花了11个小时分解了4个128的乘积，谁能想到呢，CCTF 真有蛮力分解的题还放在了 tough 里。然后就是我搞了一下午的多变量，只有大概的思路，然后提议了一手要找论文，leu秒搜到了，我大致过了下论文逻辑基本就确定了，准备把现成的poc连上去打，写一半的时候我突然想通了，一直有个直接能bypass的逻辑没理清楚。做完之前 yolbby 和小鸡块也过掉了最后一个 tough，那就只剩下 0 解 Medium 。最后四支队伍也都是差这个题，手速原因非常幸运地拿到了🥈。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/461742845.jpeg" alt="461742845"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D.png" alt="CCTF"></p>
<p>　　几乎是在期末周的时间，和 HASHTEAM 进行了最后一把 CISCN，去的南京。结束了打了三年的 CISCN，虽然三年都没进决赛，但是感觉后面学弟们的机会还是比较大，氛围也是逐渐好了起来🎉。预计这之后应该能取得不错的成绩。</p>
<p>　　六月份考完期末就是夏令营的时间，也没多想，因为很早联系好了老师，投了的浙大、上交、信工所也全都入营了，然后浙大这边的周期比较长，是实打实的做项目而不是纯粹的面试，感觉非常合适，就完全没管其他的学校了。接着就是在 ZJU 的快乐暑假，由于我们这级保研政策得到保研前公布，而大三一整个摸鱼导致绩点往下掉了快十名，需要拿到竞赛加分才行，所以那个时候还挺折磨的虽然说是感觉能拿到。但是真正在 ZJU 开始夏令营之后几乎是完全忘记了这回事，最为神奇的是组里面的一些学长因为打 CTF 的原因发现之前甚至都一起打过比赛甚至认识但是只知道 ID。所以融入的算是非常快了，基本在为期一个月的夏令营时间都是过的很开心，上下午捣鼓 idea，晚上和大家打球，非常 nice。中间去玉泉校区那边逛了逛，确实是非常有年代那边，环境也很好，但是住宿啥的就比不上水博园这边。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2166.jpeg" alt="IMG_2166"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2168.jpeg" alt="IMG_2168"></p>
<p>　　夏令营结束 StrawHat 在杭州这边打 DEFCON，我觉得应该不会有密码，但是就在玉泉附近，所以我还是过去了，最后碰到了比较好玩的 Re/Crypto AWD，也是不亏。大致内容就是防守部分写一个64位的小型类哈希方案，然后攻击部分就是分析其他队伍的源码，然后求解。最开始玩的比较开心，因为刚上来大家传的一些防守都非常 trivial 。但是后面就变得阴间起来了，一些队伍开发了自动化的更改参数和少量代码逻辑，再加上这种类似对称的结构很难短时间分析出来，后面就基本没啥能干的活了。最后 StrawHat👒 又拿了第五。</p>
<p>　　打完之后回学校参加了密码数学挑战赛的决赛，由于大半个暑假基本都在夏令营这边也没怎么做后续的优化，后面微调了下第二部分的逻辑就上交了。这次决赛来了非常多的 CTF 选手，比赛前的晚上 Deebato 喊大家一起吃了个饭，也是大型网友面基了。这比赛也算是我第一次上台答辩，属于是完全没经验。之前比赛的答辩纯靠队友带，给我整的很头疼。然后就尴尬了，本着评委老师应该只关注内容不会关注形式的心理，进行了一手稿的念，念完之后就感觉我真的很抽象。后面问了下其他人发现都是脱稿😭。答辩完大伙又一起去了周边的烧烤，开始吐槽神奇的牛顿多面体，也聊了很多，具体聊了啥我也忘了☹️。最后只拿了三等奖，也是符合预期毕竟花的时间有点少。总的来说还行，体验了一把，希望之后还能再玩玩，如果题目合适的话🤔。</p>
<p>　　再后来就是在学校的为期将近一个月的焦虑时间，从8/23比完赛到9/13，因为一直不确定学校给竞赛的政策，稍微有点折磨。甚至还去问了手教务老师也没给我准确的答复。最终很幸运地，政策依然是保持和往年一样也是成功加上了，并且由于学校神奇的加分政策综合排名还给加到了专业 rank1。</p>
<p>　　拿到保研名额后就轻松了很多，购入了第一台 switch，快乐地玩耍了几天，这之后也是把宝可梦、马里奥、塞尔达这种大IP都玩了遍。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2854.JPG" alt="IMG_2854"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2855.JPG" alt="IMG_2855"></p>
<p>　　到了九月底的时候，小鸡块从哪了解到了金融密码杯，拉大🔥一起打一打。我看了下给的奖金很多，觉得可以玩。然后小鸡块、我、yolbby 和 Zima 再次顶着 cyberCryer 出征。但是这比赛离谱的点在于它是密码杯，但是初赛是 CTF 的全方向，所幸各个方向基本都是签到难度。我把二进制都解决了，发现队友其他方向也非常猛，最后初赛打了个 Rank1，顺利拿到了苏州线下旅游机会。</p>
<p>　　还有月初的时候 Nu1L 打了一手 BlackHatmea，也拿到了线下机会，并且都集中在11月。于是我在学校待到了10月底，搬运了一下这三年的东西然后打算回家宅到旅游开始。这中间把 N1CTF2024 的题也出了，今年我出了三道，最好玩的还是那道矩阵大师。我大概很久之前就想出一个把 Lattice 和 Code 都涵盖的题目，最终也是靠着脑洞给缝合上了。由于比赛时间较短，完整预期做出了的只有 NeSE，看 discord 上的评价应该还是比较好玩。但是因为出的比较赶导致有一些神奇的非预期，不过都能接受，也是很不错的想法，最终非常平均地收获了三个4解。</p>
<p>　　接下来就是线下旅游第一站苏州，在赛前我们就已经计划好了，因为这比赛逆向部分的权重远大于密码。我们几乎只能做出来密码的部分，逆向部分肯定没法做，于是小鸡块早早在小🍠上找到了合理的路线。在第一天上午做完所有能做的密码部分后我们就撤了。然后开启了为期一周的苏州之旅，实际上只有我和 yolbby 游满了，zima 因为临时的论文答辩玩了一天就走了，小鸡块玩了四天，之后有另外一个比赛。我打算卡下一场比赛的机票，但是中间几天时间回家有点亏，所以一直在苏州呆了整整一周。u1s1我大概是把苏州所有大景点都游过一遍，手机相册这几天的照片占比已经达到了 1/3 的程度。确实之前的比赛很少能爽玩，基本也只是打完就走。感觉最好玩的还是狮子林的假山还有七里山塘、平江路那边，另外狮子山的夜景也很绝。并且苏州这边应该也是打卡大户，旅拍的非常多。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2513.jpeg" alt="IMG_2513"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2585.jpeg" alt="IMG_2585"></p>
<p>　　第二站利雅得🇸🇦，因为也是第一次出国玩，出去之前比较担心我的听力，毕竟6级听力就从没听懂过。实际上也确实，一些必要的东西可能配合肢体动作也能沟通，但是更细节的问题就很难表达的清楚了。前三天都是比赛，可能也是太久没打 CTF 的原因显得非常生疏，过题速度也比较慢。今年的 Crypto 题目质量参差不齐，感觉远低于去年。但是最后一天的密码我做的也是有点离谱，后面回想起来不知道当时在想什么，最后一小时的时候我已经完全解决问题了，只要把两部分代码拼起来就ok，但是似乎我又找到了一个更好更快的解法，然后开始推新解法。结果推到最后十几分钟开始测试怎么测都不对，发现漏题目条件了，只能用原来的解法打。只剩十分钟又火急火燎地去拼之前的做法，然后没拼完，最后 Nu1L 拿了🥉，感觉有点背锅。比赛结束主办方给选手留出了两天的游玩，因为是他们这边包的差旅，所以我们还能在利雅得呆两天。后面就是和队友参观沙特的国家博物馆，吃一些这边的特色，前几天因为怕各种不确定因素影响比赛，大伙连吃了三天薯条汉堡什么的。最后一天 shikaku 一直在微信给我发他们队在这边的旅游记录，真坏啊☹️。另外这次也是坐了最久的长途，总共五个人给拆成了三种行程，给我的行程还得在香港中转，一趟过去飞机上的时间就超过12小时了😣。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2856.jpeg" alt="IMG_2856"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2741.jpeg" alt="IMG_2741"></p>
<p>　　回家之后也就没有什么其他安排了，打磨打磨之前暑假做的想法，然后闲下来的周末和 Nu1L 打了两场 CTF。因为想了下今年 CTF 确实没怎么打特别是国际赛可能一只手都能数过来。最后AK了TSGCTF，0CTF做了 3/4 。感觉还行就是打的这几天都还挺累，量稍微有点多。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/4cc143ed-3fd8-43a4-a538-d233f8c0d55c.png" alt="4cc143ed-3fd8-43a4-a538-d233f8c0d55c"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241230143440837.png" alt="image-20241230143440837"></p>
<p>　　总的来说今年过的还比较幸运👼，没有什么糟糕😈的事情发生。希望25年能维持健康的睡眠时间💤，继续捣鼓捣鼓密码学相关的东西，新的一年一切都顺顺利利吧。</p>
<p>　　　　　　　　　　　　　<img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/IMG_2858.jpeg" alt="IMG_2858"></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Intro 2 Isogeny</title>
      <link>https://h45h.fun/posts/intro-2-isogeny/</link>
      <pubDate>Fri, 01 Nov 2024 18:09:10 +0800</pubDate>
      
      <guid>https://h45h.fun/posts/intro-2-isogeny/</guid>
      <description>TL:DR 一些关于 SIDH、CSIDH 的直观理解，以及此前出过或遇见的偏简单适合入手的同源题目。
今年暑假 Crypto Hack 更新了一些与 Isogeny 相关的东西，比较推荐上手做一做，适合入门。
Isogeny Background 曲线同源不同于传统密码学中曲线离散对数(ECDLP)的内容，在此前我们更多地研究已知等式 $[a]P=Q$ 中的 $P,Q$ 要求找到 $[a]$。这相当于是考虑点之间的关系，但在曲线同源中研究的是曲线之间的关系。由于量子计算机以及 Shor 算法的产生，后量子密码学得到了很多的关注，基于曲线同源的密码学就是其中一种，在此前Nist后量子的候选中还有一些其他的诸如基于格，基于编码，基于多变量，基于哈希函数，基于MPC的密码体系等等。相比其他体系基于曲线同源的密码学优势在于其密钥短，但缺点是计算速度较慢。
Curve Isogeny（曲线同源，下简记为同源）是什么？🤔
同源其实就是一种态射，或者说是一个有理函数。对于曲线 $E_1,E_2$ ，映射 $\phi:E_1\rightarrow E_2$ 满足对于任意两点 $P,Q\in E_1$ 有 $\phi(P&#43;Q)=\phi(P)&#43;\phi(Q)$ ，并且 $\phi(O_{E_1})=O_{E_2}$ ，我们称这样的函数 $\phi$ 为曲线 $E_1$ 到 $E_2$ 的同源。
对于一个态射我们经常会考虑它的原像、像以及核($Ker(\phi)=\set{X|\phi(X)=O}$)。在与同源相关的密码系统中通常做的最多的有两种操作，在给出曲线和核的情况下计算同源，在已知同源的情况下评估原像上点在像上对应的点。
实际上除了有关曲线的同源还有各种奇怪数学结构的同源问题，像编码同源或者多变量同源等，就看怎么定义映射了。
在 SageMath 通过原像及对应的核定义同源 $\phi$
sage: ells = [*primes(3, 250), 661] sage: p = 4 * prod(ells) - 1 sage: F = GF(p, &amp;#39;i&amp;#39;) sage: A = 0 sage: E = EllipticCurve(F, [0, A, 0, 1, 0]) sage: while not (P := (p &#43; 1) // 3 * E.</description>
      <content:encoded><![CDATA[<h1 id="tldr">TL:DR</h1>
<blockquote>
<p>一些关于 SIDH、CSIDH 的直观理解，以及此前出过或遇见的偏简单适合入手的同源题目。</p>
</blockquote>
<p>今年暑假 Crypto Hack 更新了一些与 Isogeny 相关的东西，比较推荐上手做一做，适合入门。</p>
<h1 id="isogeny">Isogeny</h1>
<h2 id="background">Background</h2>
<p>曲线同源不同于传统密码学中曲线离散对数(ECDLP)的内容，在此前我们更多地研究已知等式 $[a]P=Q$ 中的 $P,Q$ 要求找到 $[a]$。这相当于是考虑点之间的关系，但在曲线同源中研究的是曲线之间的关系。由于量子计算机以及 Shor 算法的产生，后量子密码学得到了很多的关注，基于曲线同源的密码学就是其中一种，在此前Nist后量子的候选中还有一些其他的诸如基于格，基于编码，基于多变量，基于哈希函数，基于MPC的密码体系等等。相比其他体系基于曲线同源的密码学优势在于其密钥短，但缺点是计算速度较慢。</p>
<blockquote>
<p>Curve Isogeny（曲线同源，下简记为同源）是什么？🤔</p>
</blockquote>
<p>同源其实就是一种态射，或者说是一个有理函数。对于曲线 $E_1,E_2$ ，映射 $\phi:E_1\rightarrow E_2$ 满足对于任意两点 $P,Q\in E_1$ 有 $\phi(P+Q)=\phi(P)+\phi(Q)$ ，并且 $\phi(O_{E_1})=O_{E_2}$ ，我们称这样的函数 $\phi$ 为曲线 $E_1$ 到 $E_2$ 的同源。</p>
<p>对于一个态射我们经常会考虑它的原像、像以及核($Ker(\phi)=\set{X|\phi(X)=O}$)。在与同源相关的密码系统中通常做的最多的有两种操作，在给出曲线和核的情况下计算同源，在已知同源的情况下评估原像上点在像上对应的点。</p>
<p>实际上除了有关曲线的同源还有各种奇怪数学结构的同源问题，像编码同源或者多变量同源等，就看怎么定义映射了。</p>
<p>在 SageMath 通过原像及对应的核定义同源 $\phi$</p>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: F = GF(p, &#39;i&#39;)
sage: A = 0
sage: E = EllipticCurve(F, [0, A, 0, 1, 0])
sage: while not (P := (p + 1) // 3 * E.random_element()): pass
sage: φ = E.isogeny(P)
</code></pre><p>核和映射之间满足的关系</p>
<pre tabindex="0"><code>sage: P.order() == φ.degree()
</code></pre><p>实际上，之前的表述并不严谨，核很明显应该为一集合，但这里只是将 $P$ 作为了参数，实际上这代表了这样一个集合 $\set{k\cdot P|k\in \mathbb{Z}}$，更简洁的可以把这记为 n-torsion (其中 $n$ 为 $P$ 的阶)。通过实验，可以发现同源的度数和核的势相等，当然应该有更严谨的说法，限于水平只能通过类似实验的方式去验证同源的大多数性质了。</p>
<blockquote>
<p>基于同源的困难问题是什么？😖</p>
</blockquote>
<p>这大概是入手同源时最费解的一个问题了，不同于此前接触过的基于大整数分解、离散对数、格上短向量问题，同源的困难性理解起来有点抽象。简单来讲就是给定原像 $E$ 和像 $E&rsquo;$ 找到它们间的映射 $\phi$ 是困难的，当然这个困难程度和我们选择的参数有关系，对于小规模参数下的问题我们只需要枚举所有可能情况即可求解。这里给出一些直觉上的理解，同源相关的困难问题往往可以视为在一个节点数特别多的复杂图结构中找到两点之间的路径，后面会提到的 SIDH 就是 2-isogeny graph, 3-isogeny graph，而 CSIDH 则是相对更工整一点的图。</p>
<p><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241024131955290.png" alt="image-20241024131032466"><img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241024131032466.png" alt="image-20241024131032466"></p>
<h2 id="basics">Basics</h2>
<blockquote>
<p>具体介绍同源相关的密码学协议前先补充一部分必要的曲线🧀。</p>
</blockquote>
<p><strong>Supersingular Elliptic Curve</strong></p>
<p>记 $q=p^k$，当满足 $\verb|#|E(F_q)\equiv1(mod\ p)$ 时我们称曲线 $E$ 为超奇异椭圆曲线。</p>
<p>实际上对于超奇异椭圆曲线的定义有非常多种，有一种比较有趣的 <em>End(E) is an order in a quaternion algebra</em>，这个定义方式可能对于理解后面 SIDH 是有益的。</p>
<p>超奇异曲线上的 ECDLP 是脆弱的，MOV attack 可以计算低嵌入度曲线上的 ECDLP。但是在同源中采用超奇异曲线在保证安全性的同时会带来更快的计算速度。</p>
<pre tabindex="0"><code>sage: E.is_supersingular()
</code></pre><p><strong>j-invariant</strong></p>
<p>用来判断两曲线是否具有同构关系的量，若两曲线的 j-invariant 相等则两曲线在当前域或其扩张上存在同构关系。</p>
<p>曲线 $E:\ y=x^3+Ax+B$  的 j-invariant 可表示为 $j(E)=j(A,B)=1728\frac{4A^3}{4A^3+27B^2}$</p>
<pre tabindex="0"><code>sage: E.j_invariant()
</code></pre><p><strong>Montgomery model</strong></p>
<p>形如 $E:\ y^2=x^3+Ax^2+x$ 的曲线，这种形式在 CSIDH 的 action group 构造上会用到。实际上这里的 $A$ 也可以视为一种不变量，在 $F_p$ 上的超奇异曲线由于 j-invariant 不足以区分曲线 $E$ 和它的二次扭转 $E&rsquo;$ ，所以 CSIDH 会选择用 $A$ 来作为一种标识曲线的方法。而 SIDH 在 $F_{p^2}$ 上 ，由于引入了 $i$ ，j-invariant 能作为曲线的标识。</p>
<pre tabindex="0"><code>sage: E.montgomery_model()
</code></pre><p><strong>Pairing</strong></p>
<p>令 $G_1,G_2,G_t$ 为相同阶的循环群，记 $e:G_1\times G_2\rightarrow G_t$ 是从直积群 $G_1\times G_2$ 到 $G_t$ 的映射，当满足下述性质时称其为双线性映射。</p>
<ol>
<li>对于 $\forall\ U,V\in G_1,\ W\in G_2$ ，$e(U+V,W)=e(U,W)\cdot e(V,W)$</li>
<li>对于 $\forall\ U\in G_1,\ V,W\in G_2,\ e(U,V+W)=e(U,V)\cdot e(U,W)$</li>
<li>对于 $\forall\ P\in G_1,P\ne O$ 存在 $Q\in G_2$ 使得 $e(P,Q)\ne1$ ，对于 $Q\in G_2$ 类似</li>
</ol>
<p>常见的 Weil pairing 和 Tate pairing 都是椭圆曲线加法群到有限域乘法群的映射，即 $G_1=G_2=E$ ，$G_t=F_q$</p>
<h2 id="sidh">SIDH</h2>
<blockquote>
<p>SIDH (Supersingular Isogeny Diffie-Hellman) 的几个关键元素：同源、超奇异、DH。</p>
</blockquote>
<p>这是一种基于同源的在超奇异曲线上类似DHKE的密码学协议。</p>
<p>在得到完整的SIDH协议前我们需要为 Alice 和 Bob 做一些准备，</p>
<p>Alice：起始曲线 $E$，$E[2^a]$ 上的 torsion basis $P_A,Q_A$，私钥 $sk_a$</p>
<p>Bob：起始曲线 $E$，$E[3^b]$ 上的 torsion basis $P_B,Q_B$，私钥 $sk_b$</p>
<p>为了保证存在 $2^a,3^b$ 为阶的点，在 SIDH 中将曲线所在域设置为 $F_{p^2}$ 其中 $p=2^a3^b-1$</p>
<p>在这个设置下超奇异曲线 $E$ 的阶为 $(p+1)^2$，那么上述的 torsion basis 都是存在的。而选择 $2^a,3^b$ 这样的结构是因为这样算的比较快，若是对于一般的 $t|p+1$，在 t 较大时通过 Vélu 公式 $O(t)$ 或者 √élu $O(\sqrt{t})$ 计算 t-isogeny 是非常慢的。但是小素数的幂这种结构能通过复合的方式进行，比如 $2^a$-isogeny 只需要 a 次 2-isogeny 就要快很多。</p>
<p>SIDH 面临的主要技术难点是超奇异曲线的自同态环非交换，结合上面所说的超奇异曲线的定义，实际上就是说 $F_{p^2}$ 上的曲线自同态环同构于四元代数的某个整环，但这个整环对乘法是一个非交换的结构，而 D-H 类型的协议需要交换性。</p>
<pre tabindex="0"><code>sage: p = 2**12 * 3**13 - 1
sage: Bpinf = QuaternionAlgebra(p)
sage: α = Bpinf.random_element()
sage: β = Bpinf.random_element()
sage: assert α*β != β*α
</code></pre><p>为了解决这个问题，SIDH在协议中引入了额外辅助点，来帮助双方最后得到一致的共享密钥。这使得SIDH并不是基于纯粹的 isogeny path problem 了，也是后面 SIDH 被攻破的原因。</p>
<p><strong>Protocol</strong></p>
<hr>
<p>Setup:</p>
<ul>
<li>$p=l_A^{e_A}l_B^{e_B}\cdot f-1$，固定 $F_{p^2}$ 上的超奇异曲线 $E$</li>
<li>Torsion bases $\set{P_a,Q_a}\in E[l_A^{e_A}]$ ，$\set{P_b,Q_b}\in E[l_B^{e_B}]$</li>
</ul>
<pre tabindex="0"><code>sage: a, b = 216, 137
sage: p = 2**a*3**b-1
sage: F.&lt;i&gt; = GF(p**2, modulus=x**2+1)
sage: E = EllipticCurve(F, [1, 0])
sage: while True:
....:     Pa, Qa = [E.random_point()*3**b for _ in range(2)]
....:     if Pa.order() == Qa.order() == 2**a and Pa.weil_pairing(Qa, 2**a).mult
....: iplicative_order() == 2**a:
....:         break
sage: while True:
....:     Pb, Qb = [E.random_point()*2**a for _ in range(2)]
....:     if Pb.order() == Qb.order() == 3**b and Pb.weil_pairing(Qb, 3**b).mult
....: iplicative_order() == 3**b:
....:         break
</code></pre><p>Key Exchange:</p>
<ul>
<li>Alice 选择随机 $sk_a\in[0,l_A^{e_A}-1]$，Bob 选择随机 $sk_b \in [0,l_B^{e_B}-1]$，Alice 将 $R=P_a+sk_a*Q_a$ 作为 Kernel 计算 $\phi_a:E\rightarrow E_a$，Bob类似通过 $S$ 计算出 $\phi_b:E\rightarrow E_b$</li>
</ul>
<pre tabindex="0"><code>sage: ska = randint(0, 2**a-1)
sage: skb = randint(0, 3**b-1)
sage: R = Pa+ska*Qa
sage: S = Pb+skb*Qb
sage: φa = E.isogeny(R, algorithm=&#34;factored&#34;)
sage: φb = E.isogeny(S, algorithm=&#34;factored&#34;)
</code></pre><ul>
<li>Alice 计算 $\phi_a(P_b),\phi_a(Q_b)$ 并发送给 Bob，Bob 类似操作。</li>
</ul>
<pre tabindex="0"><code>sage: Ea = φa.codomain()
sage: Pba, Qba = φa(Pb), φa(Qb)
sage: Eb = φb.codomain()
sage: Pab, Qab = φb(Pa), φb(Qa)
</code></pre><ul>
<li>Alice 将 $R&rsquo;=\phi_b(R)=\phi_b(P_a)+sk_a*\phi_b(Q_a)$ 作为 Kernel 计算 $\phi_{ba}:E\rightarrow E_{ba}$，Bob同理。最后由于 $E_{ab}\cong E_{ba}$，考虑 j-invariant 最终能协商到一致的密钥 $j(E_{ab})=j(E_{ba})$</li>
</ul>
<pre tabindex="0"><code>sage: Rb = Pab+ska*Qab
sage: jba = Eb.isogeny(Rb, algorithm=&#34;factored&#34;).codomain().j_invariant()
sage: Sa = Pba+skb*Qba
sage: jab = Ea.isogeny(Sa, algorithm=&#34;factored&#34;).codomain().j_invariant()
sage: assert jab == jba
</code></pre><hr>
<p>图示如下：</p>
<p>　　　　　　　　　　　　　<img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241107111825700.png" alt="image-20241107111825700"></p>
<p><strong>Security</strong></p>
<p>SIDH 基于的安全性可以转换为下面的命题</p>
<p>SupperSingular Computational Diffie-Hellman Problem(SSCDH)：给定曲线 $E_a,E_b$ 以及一些点 $\phi_a(P_b),\phi_a(Q_b),\phi_b(P_a),\phi_b(Q_a)$ ，计算 $E/\langle P_a+[sk_a]Q_a,P_b+[sk_b]Q_b\rangle$ 的 j-invariant。</p>
<p>Isogeny Path Problem：给定曲线 $E,E&rsquo;$，计算 $E$ 到 $E&rsquo;$ 之间的映射。</p>
<p>实际上将 SSCDH 换成下面这种表述方案只是给出了额外的 $E,E&rsquo;$ 间映射的两组像原像对。</p>
<p>结论就是这样非常不安全，从之前的一系列 torsion point attack 到现在 key recover attack 都是利用了所给的辅助点信息。</p>
<p>Castryck-Decru Key Recovery Attack on SIDH <a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">Repo</a></p>
<h2 id="csidh">CSIDH</h2>
<blockquote>
<p>CSIDH 中的 C 指的是 Commutative，不同于 SIDH 需要引入辅助点，这里的结构本身就是交换的。🏝️</p>
</blockquote>
<p>首先需要先建立几个会频繁出现的数学名词直觉，</p>
<p>$End(E)$: $E$ 对应的自同态环，也就是原像和像都是 $E$ 的同态映射的一个集合</p>
<p>$\mathcal{O}$ (Order): 可以简单理解为代数数域上的子环，类似高斯整环 $\mathbb{Z}[\sqrt{-1}]$ 这种就可以叫 Order</p>
<p>$\mathcal{Ell}(\mathcal{O},\pi)$: 所有自同态环与 $\mathcal{O}$ 同构的曲线类，$\pi$ 指 Frobenius 映射</p>
<p>$cl(\mathcal{O})$：理想类群，i.e. $\mathcal{O}$ 中理想集商去等价关系，直观上感觉是对 $\mathcal{O}$ 做了一个分类</p>
<p>$[\mathfrak{l}]\in cl(\mathcal{O})$: 理想类，包含了一些理想，这些理想作用在 $\mathcal{Ell}(\mathcal{O},\pi)$ 中的曲线后像同构</p>
<p>下面来看 CSIDH 中最重要的操作  <em>group action</em></p>
<p>定义：$\mathcal{O}$ 是虚二次域上的一个整环，且 $\pi\in\mathcal{O}$，$\mathcal{Ell}_p(\mathcal{O},\pi)$ 非空。那么理想类群 $cl(\mathcal{O})$ 作用在 $\mathcal{Ell}_p(\mathcal{O},\pi)$ 上自由可迁，其作用过程可表述为
$$
cl(\mathcal{O})\times \mathcal{Ell}_p(\mathcal{O},\pi)\rightarrow \mathcal{Ell}_p(\mathcal{O},\pi):\ ([\mathfrak{a}],E)\mapsto E/[\mathfrak{a}]
$$
那这个过程是怎么和同源关联起来的呢，下面更直观地理解 $([\mathfrak{a}],E)$ 的过程，一层层来翻译，考虑 $\mathfrak{a}$ 对 $E$ 的作用，因为 $\mathfrak{a}$ 是 $\mathcal{O}$ 的理想，而 $\mathcal{O}$ 同构于 $\mathcal{Ell}$ 中元素的自同态环，所以 $\mathfrak{a}$ 也可以看成自同态环的理想，其中包含了一些自同态映射，取其中每个自同态映射核的交能得到一些点的集合记为 $\widetilde{\mathfrak{a}}$，而 $E/[\mathfrak{a}]$ 也就是 $E/\widetilde{\mathfrak{a}}$ 。</p>
<p>那么这种观点下就比较方便理解 CSIDH 的交换性了，CSIDH的交换性和理想类群的交换性直接挂钩，只需要说明 $[\mathfrak{a}][\mathfrak{b}]=[\mathfrak{b}][\mathfrak{a}]$，也就是 $\mathcal{O}$ 上元素是否具有交换性，对于 CSIDH 只要验证对应的 $\mathbb{Z}[\pi]$ 也就是 $\mathbb{Z}[\sqrt{-p}]$ 就行。</p>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: K.&lt;i&gt; = NumberField(x^2+p)
sage: O = K.order([1, i])
sage: α = O.random_element()
sage: β = O.random_element()
sage: assert α*β == β*α
</code></pre><p>这样理解的话，CSIDH 的结构和常见的 Dlog 的结构是可以联想起来的，因为都是交换的结构，但是由于 Shor 算法的出现 Dlog 可以在多项式时间求解，但是对于 CSIDH 只能算是 Hidden shift problem，对其最好的攻击是 Kuperberg 的亚指数时间攻击。</p>
<p><strong>Protocol</strong></p>
<hr>
<p>Setup:</p>
<ul>
<li>选择 $p=4\cdot l_1l_2\dots l_k-1$ ，其中 $l_i$ 为小奇素数，设置一个 $F_p$ 上起始超奇异曲线 $E:y^2=x^3+x$，自同态环为 $\mathbb{Z}[\sqrt{-p}]$</li>
</ul>
<pre tabindex="0"><code>sage: ells = [*primes(3, 250), 661]
sage: p = 4 * prod(ells) - 1
sage: F = GF(p, &#39;i&#39;)
</code></pre><ul>
<li>Alice 选择私钥 $[\mathfrak{a}]$ ，Bob 选择私钥 $[\mathfrak{b}]$ ，由上面提到的 $[\mathfrak{a}]$ 与同源计算的关系，实际上 $[\mathfrak{a}]$ 可以看成做哪些 $l_i$-isogeny 。</li>
</ul>
<pre tabindex="0"><code>sage: priv1 = [randint(-3, 3) for _ in range(len(ells))]
sage: priv2 = [randint(-3, 3) for _ in range(len(ells))]
</code></pre><p>Key Exchange</p>
<pre tabindex="0"><code>sage: def csidh(A, priv):
....:     E = EllipticCurve(F, [0, A, 0, 1, 0])
....:     for sgn in [1, -1]:
....:         for e, ell in zip(priv, ells):
....:             for i in range(sgn * e):
....:                 while not (P := (p + 1) // ell * E.random_element()):
....:                     pass
....:                 P.set_order(ell)
....:                 E = E.isogeny_codomain(P)
....:         E = E.quadratic_twist()
....:     return E.montgomery_model().a2()
</code></pre><ul>
<li>分别计算 $E_a=[\mathfrak{a}]\star E,E_b=[\mathfrak{b}]\star E$</li>
</ul>
<pre tabindex="0"><code>sage: Ea = csidh(0, priv1)
sage: Eb = csidh(0, priv2)
</code></pre><ul>
<li>双方根据对方传来的 $E_b$ 或 $E_a$ 计算 $E_{ba},E_{ab}$ ，协商出一致的密钥 $A(E_{ba})=A(E_{ab})$</li>
</ul>
<pre tabindex="0"><code>sage: assert csidh(Ea, priv2) == csidh(Eb, priv1)
</code></pre><hr>
<p>图示如下：</p>
<p>　　　　　　　　　　　　　<img src="https://picture-1311455354.cos.ap-shanghai.myqcloud.com/img/image-20241108114220253.png" alt="image-20241108114220253"></p>
<p><strong>Security</strong></p>
<p>CSIDH 的安全性由 CSSCDH 的强度决定</p>
<p>CSSCDH：记 $p,E$ 均为 CSIDH 中的参数，给出 $E,[\mathfrak{a}]\star E,[\mathfrak{b}]\star E$ 计算 $[\mathfrak{a}]\star [\mathfrak{b}]\star E$ 是困难的，其中 $\mathfrak{a},\mathfrak{b}$ 为 $\mathcal{O}$ 中的随机元素。</p>
<p>由于 CSIDH 与 SIDH 不同，不需要辅助点的介入，这也使得其可以免疫大多针对 SIDH 的基于给出扭转点像的攻击。</p>
<h2 id="challenges">Challenges</h2>
<table>
<thead>
<tr>
<th style="text-align:center">CTF</th>
<th style="text-align:center">Challenge</th>
<th style="text-align:center">Difficulty</th>
<th style="text-align:center">Overview</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N1junior 2024</td>
<td style="text-align:center">IEV@L</td>
<td style="text-align:center">⭐</td>
<td style="text-align:center">中间相遇，外加一点简单pyjail</td>
</tr>
<tr>
<td style="text-align:center">M0leconCTF 2022</td>
<td style="text-align:center">SIDHalf</td>
<td style="text-align:center">⭐</td>
<td style="text-align:center">Weil pairing在同源下的应用</td>
</tr>
<tr>
<td style="text-align:center">DiceCTF 2023</td>
<td style="text-align:center">seaside</td>
<td style="text-align:center">⭐</td>
<td style="text-align:center">CSIDH 二次扭转</td>
</tr>
<tr>
<td style="text-align:center">jqctf-quals 2024</td>
<td style="text-align:center">BabyOracle2</td>
<td style="text-align:center">⭐⭐</td>
<td style="text-align:center">GPST Attack</td>
</tr>
<tr>
<td style="text-align:center">RCTF 2022</td>
<td style="text-align:center">S2DH</td>
<td style="text-align:center">⭐⭐</td>
<td style="text-align:center">Castryck-Decru Attack，有现成的repo。需要根据论文内容修改起始曲线的自同态环求法。</td>
</tr>
<tr>
<td style="text-align:center">jqctf-quals 2024</td>
<td style="text-align:center">S2DH+</td>
<td style="text-align:center">⭐⭐⭐</td>
<td style="text-align:center">起始曲线有已知的自同态环，参考 Petit&rsquo;s Attack 大致思路</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<p>[1] CSIDH: An Eﬃcient Post-Quantum Commutative Group Action <a href="https://eprint.iacr.org/2018/383.pdf">↩</a></p>
<p>[2] Supersingular isogeny key exchange for beginners <a href="https://eprint.iacr.org/2019/1321.pdf">↩</a></p>
<p>[3] Mathematics of Isogeny Based Cryptography <a href="https://arxiv.org/pdf/1711.04062">↩</a></p>
<p>[4] CSIDH方案短课（沙龙）<a href="https://su1yu4n.github.io/2024/10/15/CSIDH%E6%96%B9%E6%A1%88%E5%88%86%E4%BA%AB/">↩</a></p>
<p>[5] Divisors and Pairings <a href="https://klwu.co/knowledge/ec-basics-3-divisors/">↩</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>N1CTF2021</title>
      <link>https://h45h.fun/posts/n1ctf2021/</link>
      <pubDate>Tue, 12 Dec 2023 23:26:07 +0800</pubDate>
      
      <guid>https://h45h.fun/posts/n1ctf2021/</guid>
      <description>checkin from Crypto.Util.number import * from secret import flag p = getPrime(512) q = getPrime(512) n = p*q x = 2021*p&#43;1120*q h = (inverse(x,n)&#43;x)%n e = 65537 c = pow(bytes_to_long(flag), e, n) print(&amp;#39;n =&amp;#39;, n) print(&amp;#39;c =&amp;#39;, c) print(&amp;#39;h =&amp;#39;, h) print(&amp;#39;p0 =&amp;#39;, p &amp;gt;&amp;gt; 490) # n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793 # c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833 # h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806 # p0 = 4055618 $h=\frac{1}{x}&#43;x$
$\Rightarrow x^2-h\cdot x&#43;1(mod\ n)$
We can get high bits of q through the known p high bits.</description>
      <content:encoded><![CDATA[<h2 id="checkin">checkin</h2>
<pre tabindex="0"><code>from Crypto.Util.number import *
from secret import flag
 
p = getPrime(512)
q = getPrime(512)
n = p*q
x = 2021*p+1120*q
h = (inverse(x,n)+x)%n
e = 65537
c = pow(bytes_to_long(flag), e, n)
 
print(&#39;n =&#39;, n)
print(&#39;c =&#39;, c)
print(&#39;h =&#39;, h)
print(&#39;p0 =&#39;, p &gt;&gt; 490)
 
# n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793
# c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833
# h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806
# p0 = 4055618
</code></pre><p>$h=\frac{1}{x}+x$</p>
<p>$\Rightarrow x^2-h\cdot x+1(mod\ n)$</p>
<p>We can get high bits of q through the known p high bits.</p>
<p>$x=2021\cdot p+1120\cdot q=(2021\cdot(2^{490}\cdot p_0+p_1)+1120\cdot(2^{490}\cdot q_0+q_1))$</p>
<p>The unknown part of x is less than 501 bits</p>
<p><code>small_roots</code> can solve this with <code>epsilon=0.02</code></p>
<p>It&rsquo;s higher than the theoretical bound, may be LLL sometimes do better.</p>
<pre tabindex="0"><code>n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793
c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833
h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806
p0 = 4055618
q0 = None

head = n&gt;&gt;(1024-22)
for i in range(2**22):
    if (i*p0)&gt;&gt;22 == head:
        q0 = i
        break

PR.&lt;x&gt; = PolynomialRing(Zmod(n))
g = x+2021*2^490*p0+1120*2^490*q0
f = g^2-h*g+1

root = ZZ(f.small_roots(X=2^500, beta=1, epsilon=0.02)[0])
x0 = root+2021*2^490*p0+1120*2^490*q0
diff = isqrt(x0^2-4*2021*1120*n)
p = (x0+diff)//4042
q = (x0-diff)//2240
phi = (p-1)*(q-1)
d = inverse_mod(0x10001, phi)
m = pow(c, d, n)
print(bytes.fromhex(hex(m)[2:]))
</code></pre><h2 id="n1token1">n1token1</h2>
<pre tabindex="0"><code>from Crypto.Util.number import *
import random
from secret import flag
 
def gettoken(c):
    X = 0
    while ((pow(X, (p-1)//2, p)!=1) or (pow(X, (q-1)//2, q)!=1)):
        X = 1
        while X.bit_length() &lt; 920:
            X *= random.choice(primes)
    xp = pow(X, (p + 1)//4, p)
    xq = pow(X, (q + 1)//4, q)
    xp = random.choice([xp,-xp%p])
    xq = random.choice([xq,-xq%q])
    x = c * (xp*inverse(q,p)*q + xq*inverse(p,q)*p) % n
    return x
 
def getmyPrime(nbits):
    p = getPrime(nbits)
    while(p%4==1):
        p = getPrime(nbits)
    return p
 
primes = random.sample(sieve_base, 920)
p = getmyPrime(512)
q = getmyPrime(512)
e = 65537
n = p*q
c = pow(bytes_to_long(flag), e, n)
 
with open(&#34;output.txt&#34;, &#34;w&#34;)as f:
    f.write(&#34;n = &#34; + str(n) + &#34;\n&#34;)
    for i in range(920):
        f.write(&#34;Token #&#34;+str(i+1)+&#39;: &#39;+str(gettoken(c))+&#39;\n&#39;)
</code></pre><p>The token generating as follow,</p>
<p>$tk_i = c\cdot \sqrt{X_i}(mod\ n)$</p>
<p>$\Rightarrow tk_i^2\cdot(c^{-2})=X_i(mod\ n)$ Where $X&lt;2^{940}$</p>
<p>So we can solve this hidden number problem to recover $X_i$.</p>
<p>$\Rightarrow tk_0^2\cdot (tk_i^2)^{-1}=X_0\cdot X_i^{-1}(mod\ n)$</p>
<p>Rewriting the $X_i$ with primes&rsquo; exponent, and solve the kernel of exponent matrix in $F_2$ (only care parity)</p>
<p>Finally, we can construct $a^2=b^2(mod\ n)$, it&rsquo;s probably get the factors of n.</p>
<pre tabindex="0"><code>from Crypto.Util.number import *
from functools import reduce

f = open(&#39;output.txt&#39;, &#39;r&#39;)
f.read(4)
n = int(f.readline())
tk = []
for _ in range(920):
    tk_ = f.readline()
    st = tk_.index(&#39;:&#39;)
    tk.append(int(tk_[st+1:]))

def solver_hnp(s):
    L = matrix(QQ, 101, 101)
    L[0, 0] = 2^(940-1024)
    for _ in range(100):
        L[0, _+1] = s[_]**2%n
        L[_+1, _+1] = n
    basis = L.LLL()[1]
    g = reduce(GCD, basis[1:])
    c_ = basis[0]*2^(1024-940)//g
    return c_

c_ = solver_hnp(tk[:100])
if (c_*tk[0]**2)%n &gt; 2^940:
    c_ = -c_

X = []
for tk_ in tk:
    X.append((tk_**2*(c_)%n))

primes = set()
for x in X:
    facs = list(factor(x))
    for item in facs:
        primes.add(item[0])
        
primes = list(primes)
ch = []
for x in X:
    u = [0]*920
    facs = list(factor(x))
    for item in facs:
        u[primes.index(item[0])] = item[1]
    ch.append(u)
    
std = vector(ZZ, ch[0])
Ch = []
for i in range(1, len(ch)):
    Ch.append(std-vector(ch[i]))
    
A = matrix(Zmod(2), Ch)
ker = vector(ZZ, list(A.left_kernel().matrix()[0]))
res = ker*matrix(ZZ, Ch)
a = 1; b = 1
for i in range(len(ker)):
    if ker[i]:
        a *= tk[0]
        b *= tk[i+1]

for i in range(len(res)):
    if res[i] &gt; 0:
        b *= pow(primes[i], res[i]//2, n)
    else:
        a *= pow(primes[i], abs(res[i])//2, n)

p = GCD(a+b, n)
q = n//p
Fp = GF(p)
Fq = GF(q)
phi = (p-1)*(q-1)
d = inverse_mod(0x10001, phi)
c2 = inverse_mod(X[0], n)*tk[0]**2%n
m2 = pow(c2, d, n)
mp = Fp(m2).nth_root(2, all=True)
mq = Fq(m2).nth_root(2, all=True)

for i in mp:
    for j in mq:
        m = crt([int(i), int(j)], [p, q])
        print(long_to_bytes(m))
</code></pre><h2 id="n1token2">n1token2</h2>
<pre tabindex="0"><code>import random
from secret import flag
 
assert FLAG.startswith(&#39;n1ctf{&#39;)
assert FLAG.endswith(&#39;}&#39;)
SECRET = bytes.fromhex(FLAG[6:-1])
assert len(SECRET) == 16
 
p = 251
 
e = [1, 20, 113, 149, 219]
 
y = b&#39;&#39; 
for x in range(1, p):
    coeff = [random.choice(e)] + list(SECRET)
    y += bytes([sum(c * pow(x, i, p) for i, c in enumerate(coeff)) % p])
    
print(f&#39;Token: {y.hex()}&#39;)
</code></pre><p>We can use the prod idea to solve multiple choices problem</p>
<p>assume $F(x)=\sum_{i=1}\limits^{16}a_ix^i$</p>
<p>So the relation can be write as follow,</p>
<p>$\prod_{i=0}\limits^4(F(x_j)+e_i-y_j)=0$</p>
<p>$a_0+a_1\cdot F(x_j)+a_2\cdot F^2(x_j)+a_3\cdot F^3(x_j)+a_4\cdot F^4(x_j)+a_5\cdot F^5(x_j)=0$</p>
<p>Considering $F^j(x)$ as independent polynomial, there are total 245 unknow coefficients.</p>
<p>With 250 tokens, solving the matrix to recover all coefficient.</p>
<pre tabindex="0"><code>token = &#39;ae47d3533e10b444374ebd35f578103f94c327b5959f4580b0dc4701d089f22c282acfed2626bd9ced919547dacc96c18595468952cbedbcf518b5ec0fbc0437ea8e3bd77c5f01f73b555cc97a382df1ce28b4af7f9a5ab9c47e055044f47463c4f33bebdd4d6965599c71720b5a549a8246cb200dc4e2dccfc4765c0ac266a8a5385172aa47f834db737a3bcc725ae5a1ec8b76d1ca4800da10450b04543377efa5428584efdfdf55282e0e4410ae7848a0217a7d66f2d6c06c846a4755867dbdf61c70646f67debf44839a342e5f64e3abd2c9f5b66656edc8004cea987503793f7e07e3b60af4852e03177cae1e8ee605aab76d3a70df4e1e&#39;
p = 251
e = [1, 20, 113, 149, 219]
A = []
v = []
Z.&lt;x&gt; = PolynomialRing(Zmod(p))
for i in range(0, len(token), 2):
    tk = int(token[i:i+2], 16)
    a = []
    for e_ in e:
        a.append(e_-tk)
    f = (x+a[0])*(x+a[1])*(x+a[2])*(x+a[3])*(x+a[4])
    coeff = (list(f))[::-1]
    x0 = i//2+1
    u = []
    for _ in range(81):
        u.append(coeff[0]*x0^_)
    for _ in range(65):
        u.append(coeff[1]*x0^_)
    for _ in range(49):
        u.append(coeff[2]*x0^_)
    for _ in range(33):
        u.append(coeff[3]*x0^_)
    for _ in range(17):
        u.append(coeff[4]*x0^_)
    v.append(-coeff[-1])
    A.append(u)
    
A = matrix(Zmod(p), A)
v = vector(Zmod(p), v)
sol = A.solve_right(v)
secret = bytes(sol[-16:]).hex()
print(secret)
</code></pre>]]></content:encoded>
    </item>
    
  </channel>
</rss>